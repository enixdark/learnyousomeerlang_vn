<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="keywords" content="Erlang, concurrent, message passing, protocol, process, monitor, crash, link, actor, hot code loading" />
		<meta name="description" content="Writing a short concurrent application with Erlang primitives: processes, links, monitors, hot code loading and message passing are revisited. A primer before OTP." />
        <meta name="google-site-verification" content="mi1UCmFD_2pMLt2jsYHzi_0b6Go9xja8TGllOSoQPVU" />
		<link rel="stylesheet" type="text/css" href="static/css/screen.css%3Fv3.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shCore.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shThemeLYSE2.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/print.css" media="print" />
		<link href="rss" type="application/rss+xml" rel="alternate" title="LYSE news" />
		<link rel="icon" type="image/png" href="favicon.ico" />
		<link rel="apple-touch-icon" href="static/img/touch-icon-iphone.png" />
		<link rel="apple-touch-icon" sizes="72x72" href="static/img/touch-icon-ipad.png" />
		<link rel="apple-touch-icon" sizes="114x114" href="static/img/touch-icon-iphone4.png" />
		<title>Designing a Concurrent Application | Learn You Some Erlang for Great Good!</title>
	</head>
	<body>
		<div id="wrapper">
			<div id="header">
				<h1>Learn you some Erlang</h1>
				<span>for great good!</span>
			</div> <!-- header -->
			<div id="menu">
				<ul>
					<li><a href="content.html" title="Home">Home</a></li>
					<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
					<li><a href="rss" title="Latest News">RSS</a></li>
					<li><a href="static/erlang/learn-you-some-erlang.zip" title="Source Code">Code</a></li>
				</ul>
			</div><!-- menu -->
			<div id="content">
            <div class="noscript"><noscript>Hey there, it appears your Javascript is disabled. That's fine, the site works without it. However, you might prefer reading it with syntax highlighting, which requires Javascript!</noscript></div>
<h2>Designing a Concurrent Application</h2>

<img class="right" src="static/img/clock.png" width="224" height="232" alt="An alarm clock" title="Okay, this 'rock around the clock' pun is terrible" />

<p>Bạn đã làm quen với các khái niệm cơ bản rồi, và cũng thực hành thông qua các ví dụ nhưng tất cả những gì kể  từ đâu cuốn sách tới giờ chúng ta 
    chủ phần lớn làm việc với các mẫu ví dụ cơ bản không có tính thực tiến. Giờ là lúc chúng ta sẽ bắt đầu làm điều gì đó thú vị và nâng cao kiến thức hơn.
    Trong chương này chúng ta sẽ viết một ứng dụng nhỏ cho phép xử  lí concurrent trong Erlang.
    ứng dụng khá đơn giản và nhỏ nhưng vẫn hữu ích và hơn nữa chúng ta có thể  mở rộng nếu muốn.
    
    All fine and dandy. You understand the concepts, but then again, 
    all we've had since the beginning of the book were toy examples: calculators, trees, Heathrow to London, 
    etc. It's time for something more fun and more educational. We'll write a small application in concurrent Erlang. The application's 
    going to be small and line-based, but still useful and moderately extensible.</p>

<p>Nào giờ hay xét một ví du, hay đặt giả thiết rằng Tôi là một người sống vô tổ  chức, 
    tôi đã quên mất phải làm bài tập về  nhà, dọn dẹp căn hộ, cuốn sách này, công việc, các cuộc họp, các cuộc hẹn.  
    Phải có hẵn một tá các danh sách công việc mà thôi đã quên mất không làm hay không nhìn lại.
    Hy vọng là đôi khi bạn vẫn cần nhắc nhở những gì bạn làm ( có thể  bạn không đãng trí như tôi ), vạy điều này liên quan gì tới điều chúng ta sắp lại 
    , ah bởi ví chúng ta đạng dự định sẽ viết một ừng dụng cho phép nhắc nhờ nhanh chóng cho bạn về  các cuộc họp.
    
    I'm a somewhat unorganized person. I'm lost with homework, things to do around the apartment, this book, work, meetings, appointments, etc. 
    I end up having a dozen of lists everywhere with tasks I still forget to do or look over. Hopefully you still need reminders of what to do 
    (but you don't have a mind that wanders as much as mine does), because we're going to write one of these event reminder applications that prompt 
    you to do stuff and remind you about appointments.</p>


<h3><a class="section" name="understanding-the-problem">Understanding the Problem</a></h3>

<p>Thứ nhất bạn phải biết là chúng ta đang tính làm chuyện quaí gì vậy. 
    Ah 
      ban nói: "một ứng dụng nhắc nhở"
      tôi trả lời: "Tất nhiên rồi"
    . Nhưng chưa hết. 
    Vậy chúng ta sẽ lên kế  hoạch để  tương tác với phần mềm như thế  nào ? 
    Chúng ta muốn ứng dụng này làm được gì cho chúng ta ? 
    Làm thế  nào để  biểu diễn chương chình này dưới dạng các tiến trình.
    làm thế  nào để  biết được tin nhắn gửi những gì ?
    The first step is to know what the hell we're doing. "A reminder app," you say. "Of course," I say. But there's more. 
    How do we plan on interacting with the software? What do we want it to do for us? How do we represent the program with processes? How do we know what messages to send?</p>

<p>Dựa trên một câu nói của Edward V. Berard: <cite title="Edward V. Berard">"Việc đi trên mặt nước và phát triển phần mềm từ một đặc điểm kỹ thuật cụ thể  thật đễ  
    nếu như chúng đều đóng băng lại."</cite>
    Do đó hay hãy tìm một đặc điểm kỹ thuật cụ thể  và gắn với nó.
    Một phần nhỏ của ứng dụng sẽ cho phép làm được nhưng thứ sau:
    As the quote goes, <cite title="Edward V. Berard">"Walking on water and developing software from a specification are easy if both are frozen."</cite> 
    So let's get a spec and stick to it. Our little piece of software will allow us to do the following:</p>

<ul>
	<li>Chúng ta có thể  thêm một sự kiện. Các sự kiện có thể  có thời hạn ( thời điểm được cảnh báo ), tên sự kiện và mô tả sự kiện đó là gì.
        
        Add an event. Events contain a deadline (the time to warn at), an event name and a description.</li>
	<li>hiển thị cảnh báo khi tới thời điểm.
        Show a warning when the time has come for it.</li>
	<li>hủy bỏ một sự kiện dựa theo tên của nó. 
        Cancel an event by name.</li>
	<li>Không cân phải lưu trữ dữ liệu trên ổ  đĩa. 
        Để  chứng mình các khai niệm kiến trúc mà chúng ta sẽ xem xét, việc lưu trữ dữ liệu là không cần thiết.
        Đối với một ứng dụng thật thì cách làm này thật tệ nhưng tôi sẽ chỉ cho bạn nơi để  chèn các đoạn mã giúp cho việc lưu trữ trên ổ  đia nếu bạn muốn,
        đồng thời tôi cũng sẽ đưa ra một vài hàm hữu ích có thể  giúp cho bạn việc này. 
        No persistent disk storage. It's not needed to show the architectural concepts we'll see. 
        It will suck for a real app, but I'll instead just show where it could be inserted if you wanted to do it and also point to a few helpful functions.</li>
	<li>Bởi vì chúng ta không sử  dụng ổ  đĩa đẻ lưu trữ dữ liệu do đó chúng ta phải cập nhật dữ liệu trong khi đang chạy.
        Given we have no persistent storage, we have to be able to update the code while it is running.</li>
	<li>Việc tương tác với ứng dụng sẽ thực hiện qua câu lệnh, nhưng có thể  mở rộng về  sau hay vì câu lệnh ( sử  dụng GUI, truy cập thông qua trình duyệt web, sử  dụng  ) 
        The interaction with the software will be done via the command line, but it should be possible to later extend it so other means could be used (say a GUI, web page access, 
        thông qua phần mềm gửi tin nhắn, email, etc.)
        instant messaging software, email, etc.)</li>
</ul>

<p>Dưới đây là cấu trúc của chương trình chúng ta sẽ thực hiện 
    Here's the structure of the program I picked to do it:</p>

<img class="center explanation" src="static/img/reminder-structure.png" width="286" height="160" alt="5 components are there: A client (1) that can communicate with an event server (2) and 3 little circles labeled 'x', 'y', and 'z'. All three are linked to the event server." />

<p>Trong đó client, event server và x,y đều là các tiến trình. Chúng sẽ đảm nhiệm từng nhiệm vụ riêng:
    Where the client, event server and x, y and z are all processes. Here's what each of them can do:</p>

<h4>Event Server</h4>
<ul>
	<li>Chấp nhận các đăng ký từ phía client gửi tới 
        Accepts subscriptions from clients</li>
	<li>Chuyển tiếp các thông báo từ các tiến trình event tới từng client đã đăng ký (subscribers).
        Forwards notifications from event processes to each of the subscribers</li>
	<li>Chấp nhận các thông báo về  việc bổ sung thêm các sự kiên - events ( cần bắt đầu các tiến trình x, y, z ) Accepts messages to add events (and start the x, y, z processes needed)</li>
	<li>Chấp nhận các thông báo hủy bỏ một sự kiên ( event ) và chấm dứt các tiến trình trong một chuỗi sự kiện đó 
        Can accept messages to cancel an event and subsequently kill the event processes</li>
	<li>Cho phép client có quyền chấm dứt Can be terminated by a client</li>
	<li>Có khả năng nạp lại mã từ shell Can have its code reloaded via the shell.</li>
</ul>

<h4>client</h4>
<ul>
	<li>đăng ký sự kiện từ event server và nhận thông báo qua tin nhắn.
        Bằng cách này chúng ta có thể  dễ  dàng thiết kế  một nhóm các client đăng ký sự kiện tới event server.
        Để  bất kỳ ai trong số chúng cũng đều có khả năng phục vự như một cổng vào ( gateway ) các điểm tương tác khác nhau được đề  cập ở trên (GUI, web page, instant messaging software, email, etc.)
        Subscribes to the event server and receive notifications as messages. As such it should be easy to design a bunch of clients all subscribing to the event server. 
        Each of these could potentially be a gateway to the different interaction points mentioned above (GUI, web page, instant messaging software, email, etc.)</li>
	<li>Đưa ra yêu cầu server để  thêm một sự kiện kèm theo thông tin chi tiết về  sự kiện đó  Asks the server to add an event with all its details</li>
	<li>Đưa ra yêu cầu server để  hủy bỏ một sự kiện Asks the server to cancel an event</li>
	<li>Giám sát server ( để  biết khi nào nó ngừng hoạt động ) Monitors the server (to know if it goes down)</li>
	<li>Ngừng hoạt động event server khi cần Shuts down the event server if needed</li>
</ul>

<h4>x, y and z:</h4>
<ul>
	<li>Chỉ ra một thông báo đã sàng sàng để  kích hoạt ( bản chất chúng chỉ đơn giản là những bộ hẹn giờ 
        được kết nối với event server )
         Represent a notification waiting to fire (they're basically just timers linked to the event server)</li>
	<li>Gửi một tin nhắn tới event server khi hết thời gian Send a message to the event server when the time is up</li>
	<li>Nhận hủy bỏ môt tin nhắn Receive a cancellation message and die</li>
</ul>

<p>Lưu ý là tất cả các client (không bao gồm IM, mail, etc. Bởi vhúng ta sẽ không thực hiện chúng trong cuốn sách nay ) mà được nhận thông báo về  tất cả sự kiện cũng như hủy 
    bỏ không phải là thông tin cần cảnh báo tới khách hàng. Ứng dụng này được viết chủ yếu cung cấp kiến thúc cho tôi và bạn, vì thế  chúng ta luôn đặt giả thiết chỉ có duy nhất một 
    người dùng đang sử  dụng.    
    
    Note that all clients (IM, mail, etc. which are not implemented in this book) are notified about all events, and a cancellation is not something to warn the clients about. 
    Here the software is written for you and me, and it's assumed only one user will run it.</p>

<p>Đưới đây là tất cả các trường hợp về  các tin nhắc có thể  gửi và được mình họa qua một biểu đồ  phức tạp. Here's a more complex graph with all the possible messages:</p>

<img class="center explanation" src="static/img/reminder-bubbles-and-arrows.png" width="609" height="335" alt="A visual representation of the list above" />

<p>Biểu đồ  minh họa trên đưa ra thông tin vê tất cả các tiến trình mà chúng ta có thể  có. Như bạn thấy trong biểu đồ , các tin nhắn sẽ được biểu diễn bằng các mũi tên,
    bằng cách minh họa này chúng ta đang thực hiện chúng trong một giao thức bậc cao hoặc ít nhất là phác họa chúng. 
    This represents every process we'll have. By drawing all the arrows there and saying they're messages, we've written a high level protocol, or at least its skeleton.</p>

<p>Cũng lên cân nhắc lưu ý là Trong một ứng dụng thực tế  việc sử  dụng một tiến trình cho mỗi sự kiện ( event ) rất lãng phí và khó khăn trong việc mở rộng.'
    Tuy nhiên, Đối với ứng dùng mà chỉ có duy nhất bạn là người dùng thì như vậy là đủ.
    Ngoài ra còn một cách tiếp cận khác nữa đó là sử  dụng hàm <a class="docs" href="http://erldocs.com/18.0/stdlib/timer.html#send_after/2">timer:send_after/2-3</a> 
    để  tránh sinh ( spawn ) ra quá nhiều các tiến trình.
    It should be noted that using one process per event to be reminded of is likely going to be overkill and hard to scale in a real world application. 
    However, for an application you are going to be the sole user of, this is good enough. 
    A different approach could be using functions such as <a class="docs" href="http://erldocs.com/18.0/stdlib/timer.html#send_after/2">timer:send_after/2-3</a> 
    to avoid spawning too many processes.</p>

<h3><a class="section" name="defining-the-protocol">Defining the Protocol</a></h3>


<p>Bây giờ chúng ta dã hình dung được các thành phần giao tiếp và công việc của chúng rồi.
    Nó sẽ là một ý tưởng hay để  tạo ra danh sách các tin nhắn được gửi đi và chỉ định định dạng của chúng.
    Nào hãy băt đầu liên lạc giữa client và event server:

    Now that we know what each component has to do and to communicate, 
    a good idea would be to make a list of all messages that will be sent and specify what they will look like. 
    Let's first start with the communication between the client and the event server:</p>

<img class="center explanation" src="static/img/reminder-subscribe.png" width="486" height="163" alt="The client can send {subscribe, Self} to the event server, 
which can reply only with 'ok'. Note that both the client and server monitor eachother" />

<p>Ở đây , tôi sẽ sử  dụng hai màn hình giám sát ( monitor ) cho client và event server bởi vì rõ ràng không có sự phụ thuộc giữa chúng.
    Tại sao tôi nói vậy, vì rõ ràng bạn thấy event server có thể  hoạt động mà không cần có client nhưng ngược lại thì không.
    Chúng ta có thể  sử  dụng liên kết để  đảm đương được công việc đó nhưng dể  có thể  mở rộng hệ thống tới nhiều client, do đó 
    chúng ta không thể  đặt giả thiết rằng các client cũng sẽ crash khi event server ngừng hoạt động, và cũng không thể  
    đặt giả thiết là client có thể  tự động chuyển thành một tiến trình hệ thống và trap exits khi event server ngừng hoạt động.
    Tiếp theo chúng ta sẽ nói về  tập các tin nhắn:

    Here I chose to use two monitors because 
    there is no obvious dependency between the client and the server. 
    I mean, of course the client doesn't work without the server, but the server can live without a client. 
    A link could have done the job right here, but because we want our system to be extensible with many clients, 
    we can't assume other clients will all want to crash when the server dies. 
    And neither can we assume the client can really be turned into a system process and trap exits in case the server dies. Now to the next message set:</p>

<img class="center explanation" src="static/img/reminder-add.png" width="507" height="127" alt="The client can send the message {add, Name, Description, TimeOut}, to which the server can either reply 'ok' or {error, Reason}" />

<p>Hình trên minh họa một sự kiện được thêm vào event server. 
    Ngay sau đó một xác nhận được gửi lại dưới dạng một atom <code>ok</code>. Trong trường hợp có một sự cố  ( nguyên nhân có thể  do TimeOut được gửi sai đinh dạng ) thì 
    hoạt động đảo ngược, xóa bỏ các sự kiện có thể  được thực hiện như sau:

    This adds an event to the event server. A confirmation is sent back under the form of the <code>ok</code> atom, 
    unless something goes wrong (maybe the TimeOut is in the wrong format.) The inverse operation, removing events, can be done as follows:</p>

<img class="center explanation" src="static/img/reminder-remove.png" width="393" height="137" alt="The client can send the message {cancel, Name} and the event server should return ok as an atom" />

<p>Sau đó event server sẽ gửi một thông báo về  sự kiện đã xảy ra  The event server can then later send a notification when the event is due:</p>

<img class="center explanation" src="static/img/reminder-cs-done.png" width="472" height="114" alt="The event server forwards a {done, Name, Description} message to the client" />

<p>Tiêp đó chúng ta chỉ cần thực hiện theo hai trường hợp đặc biệt sau để  tắt event server hoặc khi nó bị crash:
    Then we only need the two following special cases for when we want to shut the server down or when it crashes:</p>

<img class="center explanation" src="static/img/reminder-shutdown.png" width="442" height="220" alt="When the client sends the 'shutdown' atom to the event server, it dies and returns {'DOWN', Ref, process, Pid, shutdown} because it was monitored" />

<p>Sẽ không có bất kỳ xác nhận nào được gửi trưc tiếp từ event server khi nó ngừng hoạt động nhưng 
    màn hình giám sát sẽ làm việc này để  cảnh báo cho chúng ta biết.
    Đó là tất cả những gì sẽ xảy ra giữa client và event server. Bây giờ chúng ta sẽ xem về  mối liên hệ giữa các tin nhắn và event server và các tiến trình event. 
    No direct confirmation is sent when the server dies because the monitor will already warn us of that. 
    That's pretty much all that will happen between the client and the event server. Now for the messages between the event server and the event processes themselves.</p>

<p>Có Một điều lưu ý ở đây là trước tiên chúng ta sẽ bắt đầu các liên kết giữa event server và các sự kiện, 
    Bởi vì chúng ta muốn đảm bảo rằng các sự kiện sẽ ngừng hoạt động ngay khi server tắt.  
    A thing to note here before we start is that it would be very useful to have the event server linked to the events. 
    The reason for this is that we want all events to die if the server does: they make no sense without it.</p>

<p>Ok, hay qua lại các sự kiện. Khi event server tạo ra chúng, nó sẽ gán một đinh danh cụ thể  cho mỗi sư kiện đó ( tên sự kiện )
    . Một khi một trong số  các sự kiện này tới thời điểm kích hoạt, nó sẽ gửi một thông báo cùng với nội dung:
    
    so back to the events. When the event server starts them, it gives each of them a special identifier (the event's name). 
    Once one of these events' time has come, it needs to send a message saying so:</p>

<img class="center explanation" src="static/img/reminder-es-done.png" width="378" height="133" alt="An event can send {done, Id} to the event server" />

<p>Nói một cách kahcs, các sự kiện sẽ phải theo dõi các cuộc gọi hủy bỏ từ event server 
     On the other hand, the event has to watch for cancel calls from the event server:</p>

<img class="center explanation" src="static/img/reminder-cancel.png" width="386" height="130" alt="The server sends 'cancel' to an event, which replies with 'ok'" />

<p>Vậy là chúng ta đã giới thiệu gần hết các loại tin nhắn rồi, tin nhắn cuối cùng chúng ta cần cho giao thức đó là 
    thông báo cho phép event server cập nhật , nâng cấp server.  
    And that should be it. One last message will be needed for our protocol, the one that lets us upgrade the server:</p>

<img class="center explanation" src="static/img/reminder-code-change.png" width="426" height="139" alt="the event server has to accept a 'code_change' message from the shell" />

<p>Không cần thiết phải trả lời tin nhắn này. khi chúng ta bắt đầu đi vào viết ứng dụng bạn sẽ thấy rõ.
     
    No reply is necessary. We'll see why when we actually program that feature and you'll see it makes sense.</p>

<p>Từ những phân tích trên chúng ta đã xác định được giao thức và ý tưởng chung về  cấu trúc của hệ thống phân cấp tiến trình rồi, giờ là chúng ta có 
    thể  bắt tay vào triển khai dự án được rồi.
    Having both the protocol defined and the general idea of how our process hierarchy will look in place, we can actually start working on the project.</p>


<h3><a class="section" name="lay-them-foundations">Lay Them Foundations</a></h3>

<img class="right" src="static/img/cement.png" width="364" height="203" alt="A cement truck" />

<p>Trước khi bắt đầu, chúng lên đưa ra một cấu trúc thư mục chuẩn trong Erlang, nó sẽ có dang như sau:
    To begin with it all, we should lay down a standard Erlang directory structure, which looks like this:</p>

<pre class="expand">
ebin/
include/
priv/
src/
</pre>

<p>Trong đó thư mục <code>ebin/</code> sẽ chứa các file được biên dịch. Thư mục <code>include/</code> dùng để  lưu trữ các file record có định dạng <code>.hrl</code>,
    các file này sẽ được chèn vào bên trong các ứng dụng khác, các file định dạng <code>.hrl</code> riêng, các file mà chỉ dùng với ứng dụng hiện tại thì  
    thường được đặt trong thư mục <code>src/</code>. Thư mục <code>priv/</code>, đây là thư mục chưa các file thực thi có thể  tương tác được với Erlang,
    chúng bao gồm một số các driver. Tuy nhiên với dự án này, chúng ta sẽ không sử  dụng tới các file trong thư mục này. 
    Cuối cùng thư mục <code>src/</code>, đây sẽ là thư mục chứa các file <code>.erl</code>.
    
    directory is where files will go once they are compiled. The <code>include/</code> directory is used to store <code>.hrl</code> 
    files that are to be included by other applications; the private <code>.hrl</code> files are usually just kept inside the <code>src/</code> directory. 
    The <code>priv/</code> directory is used for executables that might have to interact with Erlang, such as specific drivers and whatnot. 
    We won't actually use that directory for this project. Then the last one is the <code>src/</code> directory, where all <code>.erl</code> files stay.</p>

<p>Ngoài ra trong các dự án tiêu chuẩn Erlang, cấu trúc thư mục này có khác biệt đôi chút.
    Thư mục <code>conf/</code> có thể  được thêm vào các file cấu hình để  xác định cáu hình cho hệ thống, ứng dụng.
    Các file tài liệu sẽ nằm trong thư mục <code>doc/</code> và các thư viện của bên thứ 3 mà ứng dụng của bạn sử  dụng sẽ đặt trong thư mục 
    <code>lib/</code>. Hầu hết cấu trúc thư mục chuẩn của Erlang sẽ như vậy một số  trường hợp, trong các ứng dụng thực tế  khác có thể  sẽ đặt tên các thư mục 
    khác nhau nhưng ý nghĩa không thay đổi nhiều. Riêng bốn thư mục đề  cập phía trên thường sẽ không thay đổi mấy bởi vì chúng là một phần trong 
    <a class="docs" href="http://www.erlang.org/doc/design_principles/applications.html#id71171" title="Reference page only, don't expect to understand everything out of it">
        standard OTP practices</a>.</p>

    In standard Erlang projects, this directory structure can vary a little. A <code>conf/</code> directory can be added for specific configuration files, 
    <code>doc/</code> for documentation and <code>lib/</code> for third party libraries required for your application to run. 
    Different Erlang product on the market often use different names than these, 
    but the four ones mentioned above usually stay the same given they're part of the
     <a class="docs" href="http://www.erlang.org/doc/design_principles/applications.html#id71171" title="Reference page only, don't expect to understand everything out of it">
        standard OTP practices</a>.</p>

<h3><a class="section" name="an-event-module">An Event Module</a></h3>

<p>Nào hãy mở thư mục <code>src/</code> lên và tạo một file module và đặt tên là <a class="source" href="static/erlang/event.erl.html">event.erl</a>,
    file module này sẽ thực hiện các sự kiện x, y, z như hình vẽ trước đó ).
    Chúng ta bắt module này trước tien vì nó là một trong những module có ít phụ thuộc nhất: 
    chúng ta có thể  chạy thử  nó mà không cần phải thực hiện các chức năng cho event server hay client.
         
    Get into the <code>src/</code> directory and start an <a class="source" href="static/erlang/event.erl.html">event.erl</a> module, which will 
    implement the x, y and z events in the earlier drawings. 
    I'm starting with this module because it's the one with the fewest dependencies: we'll be able to try to run it without needing to implement the event server or client functions.</p>

<p>Trước khi bắt tay vào viết code, tôi phải nhắc bạn rằng giao thức này của chúng ta phát triển vẫn chưa thực sự đầy đủ.
    Trong giao thức này nó sẽ giúp chúng ta hiển thị quá trình gửi dữ liệu giữa các tiến trình với nhau nhưng sẽ không mô tả chi tiết quá trình gửi: 
    vd như cách địa chỉ của các tiến trình đang hoạt động như thế  nào thay vào đó những gì chúng ta đang sử  dụng là tài liệu tham khảo hay tên.
    Hầu hết các tin nhắn sẽ được bao bọc trong một bộ có dạng  <code>{Pid, Ref, Message}</code>, trong đó <var>Pid</var>  là định danh của tiến trình gửi đi 
    và <var>Ref</var>  là định danh duy nhất của tin nhắn, để  giúp chúng ta biết được tin nhắc phản hồi đó tới từ ai.
    Trong trường hợp nếu chúng ta gưi quá nhiều tin nhắc trước khi tìm kiếm, đợi phản hồi, thì chúng ta sẽ không thể  biết được sẽ phản hồi tin nhắn ra sao nếu không có 
    một địa chỉ tham chiếu. 

    Before really writing code, I have to mention that the protocol is incomplete. It helps represent what data will be sent from process to process, 
    but not the intricacies of it: how the addressing works, whether we use references or names, etc. Most messages will be wrapped under the form <code>{Pid, Ref, Message}</code>,
     where <var>Pid</var> is the sender and <var>Ref</var> is a unique message identifier to help know what reply came from who. 
     If we were to send many messages before looking for replies, we would not know what reply went with what message without a reference.</p>

<p>Giờ chúng ta sẽ bắt đầu viết, phần cốt lõi quá trình thực thi các đoạn mã trong module <code>event.erl</code> sẽ là hàm <code>loop/1</code>, nếu bạn nhớ
    giao thức mà chúng ta đã phác thảo lúc trước thì nó sẽ thực hiện tương tự như vậy:

    So here we go. The core of the processes that will run <code>event.erl</code>'s code will be the function <code>loop/1</code>, 
    which will look a bit like the following skeleton if you remember the protocol:</p>

<pre class="brush:erl">
loop(State) -&gt;
    receive
        {Server, Ref, cancel} -&gt;
            ...
    after Delay -&gt;
        ...
    end.
</pre>

<p>Ở đây, chúng ta thấy sủ dụng timeout để  thông báo một sự kiện đã tới cũng như cách để  server hủy bỏ một sự kiện.
    Hãy để  ý biến <var>State</var> trong hàm 'loop', biến này sẽ phảu chứa dữ liệu giống như giá trị timeout ( đơn vị là giây ), 
    tên của sự kiện ( theo thứ tự gửi thông báo có dạng <code>{done, Id}</code>.). Nó cũng cần phải biết định danh của event server để  gửi thông báo. 
    This shows the timeout we have to support to announce an event has come to term and the way a server can call for the cancellation of an event. 
    You'll notice a variable <var>State</var> in the loop. The <var>State</var> variable will have to contain data such as the timeout value (in seconds) 
    and the name of the event (in order to send the message <code>{done, Id}</code>.) It will also need to know the event server's pid in order to send it notifications.</p>

<p>tât cả những thông tin này thích hợp để  lưu trữ trạng thái của loop. Và để  thực hiện, chúng ta sẽ khai báo một bản ghi <code>state</code>
    và đặt nó ở đầu file:
    This is all stuff that's fit to be held in the loop's state. So let's declare a <code>state</code> record on the top of the file:</p>

<pre class="brush:erl">
-module(event).
-compile(export_all).
-record(state, {server,
                name="",
                to_go=0}).
</pre>

<p>Cùng với định nghĩa bản ghi <code>state</code>, chúng ta có thể  thay đổi lại hàm 'loop'một chút 
    it should be possible to refine the loop a bit more:</p>

<pre class="brush:erl">
loop(S = #state{server=Server}) -&gt;
    receive
        {Server, Ref, cancel} -&gt;
            Server ! {Ref, ok}
    after S#state.to_go*1000 -&gt;
        Server ! {done, S#state.name}
    end.
</pre>

<p>Ở đây, ở mệnh đề  <code>after</code> chúng ta sử  dụng tích của giá trị trong <code>to_go</code> với 1000 để  chuyển đổi từ đơn vị giây sang mili giây 
    Here, the multiplication by a thousand is to change the <code>to_go</code> value from seconds to milliseconds.</p>

<div class="note koolaid">
    <p><strong>Don't drink too much Kool-Aid:</strong><br />
    Lí giải vì sao tôi liên kết với biến 'Server' ở đầu hàm, đó là bởi vì nó sẽ được sử  dụng để  làm giá trị khớp mẫu trong biểu thức receive.
    Hãy nhớ lại về  cách sử  dụng bản ghi mà chúng ta đã học trong <a class="chapter" href="a-short-visit-to-common-data-structures.html#records">records are hacks!</a>,
    biểu thức  <code>S#state.server</code> sẽ ngầm gọi tới <code>element(2, S)</code>, đo đó nó không thể  coi là một mẫu hợp lệ để  khớp được.
    
    Language wart ahead! The reason why I bind the variable 'Server' in the function head is because it's used in pattern matching in the receive section. 
    Remember, <a class="chapter" href="a-short-visit-to-common-data-structures.html#records">records are hacks!</a> The expression <code>S#state.server</code> 
    is secretly expanded to <code>element(2, S)</code>, which isn't a valid pattern to match on.</p>
	
    <p>Mặc dù vậy nó hoạt động dược với <code>S#state.to_go</code> như một phần của mệnh đề  <code>after</code>, đó là bởi vì
        vẫn còn một biểu thức chưa được đanh giá có thể  bị trì hoãn.
        
        This still works fine for <code>S#state.to_go</code> after the <code>after</code> part, because that one can be an expression left to be evaluated later.</p>
</div>

<p>Giờ chúng ta sẽ kiểm tra hàm này: Now to test the loop:</p>
<pre class="brush:eshell">
6&gt; c(event).
{ok,event}
7&gt; rr(event, state).
[state]
8&gt; spawn(event, loop, [#state{server=self(), name="test", to_go=5}]).
&lt;0.60.0&gt;
9&gt; flush().
ok
10&gt; flush().
Shell got {done,"test"}
ok
11&gt; Pid = spawn(event, loop, [#state{server=self(), name="test", to_go=500}]).
&lt;0.64.0&gt;
12&gt; ReplyRef = make_ref().
#Ref&lt;0.0.0.210&gt;
13&gt; Pid ! {self(), ReplyRef, cancel}.
{&lt;0.50.0&gt;,#Ref&lt;0.0.0.210&gt;,cancel}
14&gt; flush().
Shell got {#Ref&lt;0.0.0.210&gt;,ok}
ok
</pre>

<p>Có rất nhiều thứ được nhìn thấy ở đây. Đầu tiên, chúng ta đã nạp bản ghi từ module sự kiện ( event ) vào trong shell bằng lệnh  <code>rr(Mod)</code>,
    tiếp đó chúng ta sinh (spawn) ra tiến trình sự kiện ( hàm loop ) và sử  dụng tiến trình shell hiện tại thay thế  cho tiến trình server  (<code>self()</code>).
    sư kiện này lên kích hoạt sau 5 giây. xét thời điểm ở biểu thức thứ 9 , khi đó chương trình của chúng ta đã chạy được 3 giấy rồi, và ở biểu thứ thứ 10 là 6s,
    như bạn nhin thấy chúng ta đã nhận được thông báo <code>{done, "test"}</code> tại lần thử  thứ hai.

    Lots of stuff to see here. Well first of all, we import the record from the event module with <code>rr(Mod)</code>. Then, we spawn the event loop 
    with the shell as the server (<code>self()</code>). This event should fire after 5 seconds. The 9th expression was run after 3 seconds, 
    and the 10th one after 6 seconds. You can see we did receive the <code>{done, "test"}</code> message on the second try.</p>

<p>Tiếp sau đó, tôi đã thử  tính năng hủy bỏ ( cùng với việc tạo ra một sự kiện và kích hoạt nó sau ̀500 giây ).
    bằng cách tạo ra một tiến trình đinh danh tham chiều (reference), và gửi đi một tin nhắn, ngay lập tức 
    tôi nhận được một phản hồi cùng với nội dung là <code>ok</code>. Như bạn thấy tôi đã hận được phản hồi từ chính 
    tiến trình đinh danh tham chiều này chứ không phải từ bất kỳ một tiến trình nào khác trên hệ thống.
    
     Right after that, I try the cancel feature (with an ample 500 seconds to type it). 
     You can see I created the reference, 
     sent the message and got a reply with the same reference so I know the <code>ok</code> 
     I received was coming from this process and not any other on the system.</p>

<p>Để  giải thích lí do vì sao việc hủy bỏ tin nhắn được bao bọc cùng với tiến trình tham chiều 
    nhưng tinh nhắc <code>done</code> thì không, đó là bởi vì chúng ra không mong đợi nó 
    tới từ một tiến trình xác đinh ( bất cứ tiến trình nào cũng làm được và chúng ta sẽ không so sánh để  khơp trong mệnh đề  receive)
    cũng như muốn nhận phản hồi từ tiến trình đó. Ngay lúc này, tôi muốn làm một số  kiểm tra, trong kiếm tra này tôi sẽ 
    tạo một sự kiện và thời gian đợi của nó là 1 năm.
    Vậy điều gì sẽ xảy ra nếu một sự kiện xảy ra trong năm tiếp theo ? 
    
    The reason why the cancel message is wrapped with a reference
     but the <code>done</code> thì không, message isn't is simply 
     because we don't expect it to come from anywhere specific (any place will do, we won't match on the receive) 
     nor should we want to reply to it. There's another test I want to do beforehand. What about an event happening next year?</p>
<pre class="brush:eshell">
15&gt; spawn(event, loop, [#state{server=self(), name="test", to_go=365*24*60*60}]).
&lt;0.69.0&gt;
16&gt; 
=ERROR REPORT==== DD-MM-YYYY::HH:mm:SS ===
Error in process &lt;0.69.0&gt; with exit value: {timeout_value,[{event,loop,1}]}
</pre>

<p>Ouch. Có vẻ như chúng ta đã gặp một hạn chế , thự tế  là giá trị timeout trong Erlang bị giới hạn khoảng 50 ngày ( quy đổi ra mili giấy hay nói chính xác 
    là tối đa giá trị cho phép của timeout trong Erlang là 2^32 hay 16#ffffffff ).
    Có lẽ diều này không đáng kể  lắm nhưng tôi sẽ chỉ ra 3 lí do của lỗi này cho bạn thấy:
    It seems like we hit an implementation limit. It turns out Erlang's timeout value is limited to about 50 days in milliseconds. 
    It might not be significant, but I'm showing this error for three reasons:</p>

<ol>
	<li>Lí đầu tiên đó là nó như ngoạm vào mông khi chúng ta đang viết module này và kiểm tra xuyên suốt nửa chương này rồi.
        It bit me in the ass when writing the module and testing it, halfway through the chapter.</li>
	<li>Lí do tiếp theo đó là Erlang không phải là ngôn ngữ lý tưởng để  làm bất cứ công việc ( task ) nào cả, 
        những gì chúng ta thấy ở đây là hậu quả của việc sử  dụng bộ tính giờ theo cách mà không được các nhà phát triển khuyến khích.
        Erlang is certainly not perfect for every task and what we're seeing here is the consequences of using timers in ways not intended by the implementers.</li>
	<li>Cuối cùng thì thực sự lỗi này không phải vấn đề  quá lớn gì hết, và chúng ta hoàn toàn có thể  tránh được lỗi này 
        That's not really a problem; let's work around it.</li>
</ol>

<p>Để sửa lại sai xót tối quyết định sẽ viết lại một hàm có chức năng chia nhỏ giá trị timeout thành nhiều phần khi nó vượt quá giá trị cho phép trong Erlang.
        Tất nhiên là hàm <code>loop/1</code> cũng sẽ yêu cầu thay đổi một chút. Nói chung, chúng ta sẽ chia nhỏ thời gian thành các phần bằng nhau mỗi phần sẽ 
        dài khoảng 49 ngày ( bởi vì giới hạn cho phép trong Erlang là xấp xỉ ̀50 ngày ), sau đó đặt các phần còn lại này vào danh sách sao cho tổng 
        của chúng ( tính theo đơn vị giây ) bằng với giá trị gốc.    
   
    The fix I decided to apply for this one was to write a function that would split the timeout value into many parts if turns out to be too long. 
    This will request some support from the <code>loop/1</code> function too. So yeah, the way to split the time is basically divide it in equal parts of 49 days 
    (because the limit is about 50), and then put the remainder with all these equal parts. The sum of the list of seconds should now be the original time:</p>

<pre class="brush:erl">
%% Because Erlang is limited to about 49 days (49*24*60*60*1000) in
%% milliseconds, the following function is used
normalize(N) -&gt;
    Limit = 49*24*60*60,
    [N rem Limit | lists:duplicate(N div Limit, Limit)].
</pre>

<p>Bằng cách sử  dụng List Compréhesion và hàm <code><a class="docs" href="http://erldocs.com/18.0/stdlib/lists.html#duplicate/2" title="THE MAGICAL LIST THAT CAN DUPLICATE ITSELF">lists:duplicate/2</a></code> 
    chúng ta sẽ truyền vào tham số thứ hai của hàm là một biểu thức mà đã định nghĩa trước và 
    lặp lại dựa trên giá trị trong tham số  thứ nhất ( ví dụ: <code>[a,a,a] = lists:duplicate(3, a)</code>).
    nếu chúng ta truyền một giá trị <code>98*24*60*60+4</code> vào trong hàm <code>normalize/1</code>, 
    kết quả chúng ta sẽ nhận được sẽ là <code>[4,4233600,4233600]</code>. Tiếp đó hàm <code>loop/1</code> của chúng ta sẽ thay đổi lại như 
    sau để  phù hợp với định dạng mới:

    will take a given expression as a second argument and reproduce it as many times as the value of the first argument (<code>[a,a,a] = lists:duplicate(3, a)</code>). 
    If we were to send <code>normalize/1</code> the value <code>98*24*60*60+4</code>, it would return <code>[4,4233600,4233600]</code>. 
    The <code>loop/1</code> function should now look like this to accommodate the new format:</p>

<pre class="brush:erl">
%% Loop uses a list for times in order to go around the ~49 days limit
%% on timeouts.
loop(S = #state{server=Server, to_go=[T|Next]}) -&gt;
    receive
        {Server, Ref, cancel} -&gt;
            Server ! {Ref, ok}
    after T*1000 -&gt;
        if Next =:= [] -&gt;
            Server ! {done, S#state.name};
           Next =/= [] -&gt;
            loop(S#state{to_go=Next})
        end
    end.
</pre>

<p>Bây giờ nó đã hoạt động mà không có vấn đề  gì, nếu không tin bạn có thể  thử  kiểm tra. 
    Ngoài ra bạn cũng có thể  thử  cả trường hợp giá trị timeout trong vài năm.
    Vậy nó hoạt động như thế  nào ? 
    Đầu tiên nó sẽ trích xuất phần tử  đầu tiên trong danh sách biến <code>to_go</code> ra và chuyển sang trạng thái chờ với 
    thời gian chờ bằng đúng thời gian mà đã trích xuất. sau đó khi thời gian chờ kết thức, nó sẽ tìm kiếm 
    trong danh sách và lấy phần tử  của timeout tiếp theo ra nếu có, cứ tiếp tục lặp lại như vậy cho tới khi không còn phần từ nào trong danh sách nữa 
    khi đó tính từ thời gian chờ trong phần từ cuối cùng kết thúc, server sẽ nhận được thông báo.

    You can try it, it should work as normal, but now support years and years of timeout. 
    How this works is that it takes the first element of the <code>to_go</code> list and waits for its whole duration. 
    When this is done, the next element of the timeout list is verified. If it's empty, the timeout is over and the server is notified of it. 
    Otherwise, the loop keeps going with the rest of the list until it's done.</p>

<p>bạn se cảm thấy rát phiền phức khi mà mỗi lần sinh ra mới một tiến trình sự kiện lại phải gọi thủ công hàm <code>event:normalize(N)</code>,
    Đặc biệt khi bạn muốn các lập trình viên khác sử  dụng đoạn mã này mà không cần phải quan tâm tới vấn đề  trên.
    Do đó giải pháp tiêu chuẩn để  giải quyết vân đề  này đó là thêm một hàm <code>init</code> để  xứ lí tất cả chức năng liên quan tới việc khởi tạo 
    dữ liệu dùng cho hàm 'loop'. Vì chúng ta đang thực hiện, do đó chúng sẽ thêm các hàm chuẩn <code>start</code> và <code>start_link</code>:

    It would be very annoying to have to manually call something like <code>event:normalize(N)</code> every time an event process is started, 
    especially since our workaround shouldn't be of concern to programmers using our code. The standard way to do this is to 
    instead have an <code>init</code> function handling all initialization of data required for the loop function to work well. 
    While we're at it, we'll add the standard <code>start</code> and <code>start_link</code> functions:</p>

<pre class="brush:erl">
start(EventName, Delay) -&gt;
    spawn(?MODULE, init, [self(), EventName, Delay]).

start_link(EventName, Delay) -&gt;
    spawn_link(?MODULE, init, [self(), EventName, Delay]).

%%% Event's innards
init(Server, EventName, Delay) -&gt;
    loop(#state{server=Server,
                name=EventName,
                to_go=normalize(Delay)}).
</pre>

<p>Bây giờ giao diện nhìn chúng có vẻ gọn gàng hơn rồi.
    Trước khi tiến hành kiểm tra, sẽ tốt hơn là việc chúng ta có những hàm riêng ứng với từng chức năng gửi, hủy bỏ tin nhắn thay vì phải làm thủ công trên shell:  
    The interface is now much cleaner. Before testing, though, it would be nice to have the only message we can send, cancel, also have its own interface function:</p>

<pre class="brush:erl">
cancel(Pid) -&gt;
    %% Monitor in case the process is already dead
    Ref = erlang:monitor(process, Pid),
    Pid ! {self(), Ref, cancel},
    receive
        {Ref, ok} -&gt;
            erlang:demonitor(Ref, [flush]),
            ok;
        {'DOWN', Ref, process, Pid, _Reason} -&gt;
            ok
    end.
</pre>

<p>Oh! Đây là một mẹo mới! Ở đây tôi đã sử  dụng màn hình giám sát ( monitor ) để  theo dõi tiến trình có tồn tại hay không,  
    trong trường hợp nó đã ngừng hoạt động trước đó rồi, tôi sẽ tránh được việc lãng phí thời gian để  chờ đợi một cách vô nghĩa,
    thay vào đó tôi sẽ nhận được thông báo  <code>ok</code> giống với những gì mà chúng ta đã phác thảo trong giao thức.
    Nếu tiến trình phản hồi cùng với thông tin về  tiến trình tham chiếu, tức la tôi sẽ biết răng tiến trình đó sẽ sỡm ngừng hoạt động:
    như vậy tôi sẽ xóa bỏ tiến tiến trình tham chiếu này đi để  tránh nhận được các tin nhắn không cần thiết nữa.
    Lưu ý là hàm <code>flush</code> cũng được cung cấp sử dụng như một tùy chọn, nó sẽ xóa tin nhắn <code>DOWN</code> nếu nó đã đươc gửi đi trước khi 
    ngưng việc giám sát.   

    A new trick! Here I'm using a monitor to see if the process is there or not. If the process is already dead, 
    I avoid useless waiting time and return <code>ok</code> as specified in the protocol. If the process replies with the reference, 
    then I know it will soon die: I remove the reference to avoid receiving them when I no longer care about them. Note that I also supply the 
    <code>flush</code> option, which will purge the <code>DOWN</code> message if it was sent before we had the time to demonitor.</p>

<p>Let's test these:</p>
<pre class="brush:eshell">
17&gt; c(event).
{ok,event}
18&gt; f().
ok
19&gt; event:start("Event", 0).
&lt;0.103.0&gt;
20&gt; flush().
Shell got {done,"Event"}
ok
21&gt; Pid = event:start("Event", 500).
&lt;0.106.0&gt;
22&gt; event:cancel(Pid).
ok
</pre>

<p>Tuyệt nó hoạt động chính xác! Tuy vậy vẫn còn một tính nằng của module sự kiện ( event ) gây phiền phức cho chúng ta, khi sinh ra một sự kiện chúng ta cần phải xác định thời gian 
    chờ cho sự kiện đó, tuy vậy thời gian này chúng ta vẫn đang sử  dụng theo dơn vị giây, tốt hơn hết néu chúng ta có thể  sử  dụng thời gian ở định dạng chuẩn, ví dụ như 
    (<code>{{Year, Month, Day}, {Hour, Minute, Second}}</code>). Để làm điều này chúng ta chỉ cần tạo ra một hàm <code>time_to_go/1</code>, hàm này sẽ tính 
    khlảng thời gian chênh lệch giữa đô trễ  thơi gian bạn nhập vào so với thời gian hiện tại của hệ thống, mấy tính: 

    And it works! The last thing annoying with the event module is that we have to input the time left in seconds. 
    It would be much better if we could use a standard format such as Erlang's datetime 
    (<code>{{Year, Month, Day}, {Hour, Minute, Second}}</code>). Just add the following 
    function that will calculate the difference between the current time on your computer and the delay you inserted:</p>

<pre class="brush:erl">
time_to_go(TimeOut={{_,_,_}, {_,_,_}}) -&gt;
    Now = calendar:local_time(),
    ToGo = calendar:datetime_to_gregorian_seconds(TimeOut) -
           calendar:datetime_to_gregorian_seconds(Now),
    Secs = if ToGo &gt; 0  -&gt; ToGo;
              ToGo =&lt; 0 -&gt; 0
           end,
    normalize(Secs).
</pre>

<p>Oh, yeah.  <a class="docs" href="http://erldocs.com/18.0/stdlib/calendar.html" title="">module calendar</a>
    có cái tên thật hài hước. Như đã đè cập ở trên, đây là phép tính toán giữa thời điểm hiện tại trên hệ thống và khi một sự kiện được kích hoạt. 
    Nếu sự kiện đó đa qua, chúng ta sẽ trả về  giá trị <samp>0</samp> và gửi thông báo tới server sớm nhất có thể .  
    Nao giờ hãy sửa lại hàm 'init' để  gọi hàm này thay vì hàm <code>normalize/1</code>.
    Ngoài ra bạn cũng có thể  đổi tên biên <var>Delay</var> thành <var>DateTime</var> nếu như bạn muốn một cái tên mô tả chính xác ý nghĩa của đoạn mã đó hơn.

    has pretty funky function names. As noted above, this calculates the number of seconds between now and when the event is supposed to fire. 44
    If the event is in the past, we instead return <samp>0</samp> so it will notify the server as soon as it can. 
    Now fix the init function to call this one instead of <code>normalize/1</code>. You can also rename <var>Delay</var> variables to say <var>DateTime</var> 
    if you want the names to be more descriptive:</p>

<pre class="brush:erl">
init(Server, EventName, DateTime) -&gt;
    loop(#state{server=Server,
                name=EventName,
                to_go=time_to_go(DateTime)}).
</pre>

<p>Vậy là chúng ta đã hoàn thành module sự kiện này rồi, bây giờ bạn có thể  nghỉ nghơi một chút.
    Bắt đầu một sự kiện mới và thư giãn bằng cách uống một cốc sữa hay bear ( nửa lit ) và quay trở lại sau khi một thông báo về  sự kiện đó tới. 
    Now that this is done, we can take a break. Start a new event, go drink a pint (half-litre) of milk/beer and come back just in time to see the event message coming in.</p>

<h3><a class="section" name="the-event-server">The Event Server</a></h3>

<p>Tiếp theo chúng ta sẽ xét <a class="source" href="static/erlang/evserv.erl.html">event server</a>. 
    Như những gì mà giao thức của chúng ta minh họa, cấu trúc của nó sẽ có dạng như sau:

    Let's deal with the <a class="source" href="static/erlang/evserv.erl.html">event server</a>. According to the protocol, the skeleton for that one should look a bit like this:</p>

<pre class="brush:erl">
-module(evserv).
-compile(export_all).

loop(State) -&gt;
    receive
        {Pid, MsgRef, {subscribe, Client}} -&gt;
            ...
        {Pid, MsgRef, {add, Name, Description, TimeOut}} -&gt;
            ...
        {Pid, MsgRef, {cancel, Name}} -&gt;
            ...
        {done, Name} -&gt;
            ...
        shutdown -&gt;
            ...
        {'DOWN', Ref, process, _Pid, _Reason} -&gt;
            ...
        code_change -&gt;
            ...
        Unknown -&gt;
            io:format("Unknown message: ~p~n",[Unknown]),
            loop(State)
    end.
</pre>

<p>Bạn có thể  nhận thấy trước đó tôi đã bao bọc các lời gọi mà yêu cầu thông báo phản hồi có cùng một định dạng <code>{Pid, Ref, Message}</code>.
    Còn bây giờ, server sẽ cần phải lưu trũ hai thứ trong một trạng thái: đó là một danh sách các cient đã đăng ký và danh sách tất cả các tiến trình sự kiện được sinh ra và kết nối với 
    server. Nếu bạn để  ý giao thức, khi mọt sự kiện hoàn tất, server sẽ nhận được một thông báo  <code>{done, Name}</code>, nhưng gửi <code>{done, Name, Description}</code>.
    ý tưởng ở đây là có không cần thiết có nhiều truy cập và để  cho các tiến trình sự kiện xử lí những xử kiện cần thiết thôi. do vậy, dưới đây là định nghĩa của danh sách client và 
    danh sách sự kiện:    
    
    You'll notice I have wrapped calls that require replies with the same <code>{Pid, Ref, Message}</code> format as earlier. 
    Now, the server will need to keep two things in its state: a list of subscribing clients and a list of all the event processes it spawned.
    If you have noticed, the protocol says that when an event is done, the event server should receive <code>{done, Name}</code>, but send <code>{done, Name, Description}</code>. 
    The idea here is to have as little traffic as necessary and only have the event processes care about what is strictly necessary. So yeah, list of clients and list of events:</p>

<pre class="brush:erl">
-record(state, {events,    %% list of #event{} records
                clients}). %% list of Pids

-record(event, {name="",
                description="",
                pid,
                timeout={{1970,1,1},{0,0,0}}}).
</pre>

<p>Và hàm 'loop' giờ sẽ sử  dụng bản ghi ở đầu hàm như sau: 
    And the loop now has the record definition in its head:</p>

<pre class="brush:erl">
loop(S = #state{}) -&gt;
    receive
        ...
    end.
</pre>

<p>sẽ tốt hơn nếu bạn sử  dụng kiểu cấu trúc orddicts cho việc lưu trữ cả client lẫn sự kiện ( event ).
    Bởi vì như chúng ta sẽ không thẻ có hàng trăm client và sự kiện cùng lúc được.
    cấu trúc orddicts rất thích hợp để sử dụng trong trường hợp này, hãy nhớ lại cấu trúc này trong chương <a class="chapter" href="a-short-visit-to-common-data-structures.html#key-value-stores">data structures</a>
    mà chúng ta đã học trước đó. Nào giờ chúng ta sẽ viết một hàm <code>init</code> để  xứ lí:
    It would be nice if both events and clients were orddicts. 
    We're unlikely to have many hundreds of them at once. 
    If you recall the chapter on <a class="chapter" href="a-short-visit-to-common-data-structures.html#key-value-stores">data structures</a>, 
    orddicts fit that need very well. We'll write an <code>init</code> function to handle this:</p>

<pre class="brush:erl">
init() -&gt;
    %% Loading events from a static file could be done here.
    %% You would need to pass an argument to init telling where the
    %% resource to find the events is. Then load it from here.
    %% Another option is to just pass the events straight to the server
    %% through this function.
    loop(#state{events=orddict:new(),
                clients=orddict:new()}).
</pre>

<p>Chúng ta đã hoàn thành cơ bản cấu trúc và việc khởi tạo. 
    tiếp theo tôi sẽ thực hiện từng các chức năng trong từng mẫu tin nhắn mà chúng ta đã dịnh nghĩa trước đó.
    tin nhắn đầu tiên mà chúng ta xét sẽ liên quan tới việc đăng ký.
    Bởi vì chúng ta muốn lưu trữ một danh sách tất cả các ngừoi đăng ký khi một sự kiện xảy ra, và thông báo tới họ.
    Ngoài ra trong giao thức minh họa ở trên, chúng cũng cần giám sát họ.
    Việc làm này có ý nghĩa vì chúng ta không muốn giữ các client những người đã bị crash và gửi những dòng tin nhắc vô nghĩa mà không có lí do gì.

    With the skeleton and initialization done, I'll implement each message one by one. 
    The first message is the one about subscriptions. 
    We want to keep a list of all subscribers because when an event is done, 
    we have to notify them. Also, the protocol above mentions we should monitor them. 
    It makes sense because we don't want to hold onto crashed clients and send useless messages for no reason. Anyway, it should look like this:</p>

<pre class="brush:erl">
{Pid, MsgRef, {subscribe, Client}} -&gt;
    Ref = erlang:monitor(process, Client),
    NewClients = orddict:store(Ref, Client, S#state.clients),
    Pid ! {MsgRef, ok},
    loop(S#state{clients=NewClients});
</pre>

<img class="left" src="static/img/rss.png" width="154" height="156" alt="Hand drawn RSS logo" />

<p>Vậy sao bên trong hàm <code>loop/1</code> lại sử  dụng một màn hình giám sát ( monitor ), và sử  dụng định danh tham chiếu của màn hình này 
    như một khóa trong orddict để  lưu trữ thông tin của client. Tôi làm vậy bởi lí do rất đơn giản: trong một số  thời điểm, chúng ta càn phải lấy ID của client,
    khi chúng ta nhận được một tín hiệu <code>EXIT</code> từ màn hình giám sát trong đó nó sẽ chưa đinh danh tham chiếu ( điều này cho phép chúng ta loại bỏ đinh danh này trong orddict)
    So what this section of <code>loop/1</code> does is start a monitor, and store the client info in the orddict under the key <var>Ref</var>. 
    
    The reason for this is simple: the only other time we'll need to fetch the client ID will be if we receive a monitor's <code>EXIT</code> message, 
    which will contain the reference (which will let us get rid of the orddict's entry).</p>

<p>Tiêp theo chúng ta sẽ đi xét trường hợp thông báo thêm mới một sự kiện. Bằng cách này, nó có thể  sé trả lại một trạng thái lỗi. Do đó để  đảm bảo,
    chúng ta sẽ tiến hành xác thực thời gian mà chúng ta chấp nhận chúng xảy ra. Mặc dù giờ khá dễ  trong việc đăng ký một sự kiện với định dạng thời gian  
    <code>{{Year,Month,Day}, {Hour,Minute,seconds}}</code>, tuy vậy sẽ có một số  trường hợp đặc biệt, do đó chúng ta phải đảm bảo rằng không cho phép một 
    sự kiện được lên lịch vào 29/2 nếu như năm đo không phải là năm luận hay ngày nào dó mà không tồn tại ( vd như 32/1 ).
    Hơn nữa, chúng ta cũng dược được phép chấp thuận các trường hợp thời gian mà giá trị có dạng "̀5 giờ trừ đi một phút và 75̃ giây".
    Để  làm việc này chúng ta sẽ cần một hàm có chức năng xác thực giá trị thời gian cho phép:
    
    The next message to care about is the one where we add events. Now, it is possible to return an error status. The only validation 
    we'll do is check the timestamps we accept. While it's easy to subscribe to the <code>{{Year,Month,Day}, {Hour,Minute,seconds}}</code> 
    layout, we have to make sure we don't do things like accept events on February 29 when we're not in a leap year, 
    or any other date that doesn't exist. Moreover, we don't want to accept impossible date values such as "5 hours, minus 1 minute and 75 seconds". 
    A single function can take care of validating all of that.</p>

<p>Trong hàm này chúng ta sẽ sử  dụng hàm  <code><a class="docs" href="http://erldocs.com/18.0/stdlib/calendar.html#valid_date/1" title="oh, erldocs. So many links!">calendar:valid_date/1</a></code>
    để  xác thực tinh hợp lệ của ngày. Tuy nhiên có một điều không lấy làm vui là module calendar không có hàm nào xác thực thời gian với giá trị truyền vào có định dạng <code>{H,M,S}</code>,
    vì thế  chúng ta phải phải tự định nghĩa và viết hàm để  giải quyét vấn đề  này. 

    The first building block we'll use is the function 
    <code><a class="docs" href="http://erldocs.com/18.0/stdlib/calendar.html#valid_date/1" title="oh, erldocs. So many links!">calendar:valid_date/1</a></code>. 
    This one, as the name says, checks if the date is valid or not. Sadly, the weirdness of the calendar module doesn't stop at funky names: 
    there is actually no function to confirm that <code>{H,M,S}</code> has valid values. We'll have to implement that one too, following the funky naming scheme:</p>


<pre class="brush:erl">
valid_datetime({Date,Time}) -&gt;
    try
        calendar:valid_date(Date) andalso valid_time(Time)
    catch
        error:function_clause -&gt; %% not in {{Y,M,D},{H,Min,S}} format
            false
    end;
valid_datetime(_) -&gt;
    false.

valid_time({H,M,S}) -&gt; valid_time(H,M,S).
valid_time(H,M,S) when H &gt;= 0, H &lt; 24,
                       M &gt;= 0, M &lt; 60,
                       S &gt;= 0, S &lt; 60 -&gt; true;
valid_time(_,_,_) -&gt; false.
</pre>


<p>Giờ bạn có thể  sử  dụng hàm <code>valid_datetime/1</code> mà chúng ta vừa định nghĩa ở trên vào trong phần thông báo thêm mới một sự kiện: 
    function can now be used in the part where we try to add the message:</p>

<pre class="brush:erl">
{Pid, MsgRef, {add, Name, Description, TimeOut}} -&gt;
    case valid_datetime(TimeOut) of
        true -&gt;
            EventPid = event:start_link(Name, TimeOut),
            NewEvents = orddict:store(Name,
                                      #event{name=Name,
                                             description=Description,
                                             pid=EventPid,
                                             timeout=TimeOut},
                                      S#state.events),
            Pid ! {MsgRef, ok},
            loop(S#state{events=NewEvents});
        false -&gt;
            Pid ! {MsgRef, {error, bad_timeout}},
            loop(S)
    end;
</pre>

<p>Trong đoạn logic này, nếu thời gian chúng kiểm ta là họp hợp lệ, thì một tiến trình sự kiện mới sẽ được tạo ra và 
    thêm vào thông tin trạng thái của các sự kiện trên server trước khi nó gửi một thông báo để  xác thực tới tiến trình gọi ( người gọi ).
    trong trường hợp giá trị timeout không đúng, chúng ta sẽ thông báo về  lỗi cho cho client hon là việc lặng lẽ xem như không lỗi gì 
    hoặc gây crash server. Thêm nữa việc kiểm tra lên được thêm vào để  tránh xung đột tên hay gây lên một số  hạn chế nào đó ( và đừng quên cập nhật các tài liệu giao thức!) 

    If the time is valid, we spawn a new event process, then store its data in the event server's state before sending a confirmation to the caller. 
    If the timeout is wrong, we notify the client rather than having the error pass silently or crashing the server. 
    Additional checks could be added for name clashes or other restrictions (just remember to update the protocol documentation!)</p>

<p>Mẫu tin nhắc tiếp theo trong giai thức của chúng ta sẽ xem xét đó là thông báo hủy bỏ một sự kiên.
    Việc hủy một sự kiện thì không bao giờ ảnh hưởng tới phía client, do đó viết mã logic cho chúng khá dễ  dàng.   
    Bạn chỉ cần kiểm tra một sự kiên có tồn tài hay không trong bản ghi của tiến trình trang thái. Trong trường hợp nếu 
    có, hãy sử  dụng hàm  <code>event:cancel/1</code>  mà chúng đã đã định nghĩa trước đó để  xóa bỏ mà gửi trả thông báo ok.
    Ngược lại, không có gì phức tạp cả, chúng ta chỉ đơn giản nói với người dùng là mọi thứ vẫn diễn ra bình thường, sự kiện đó 
    không hoạt động, đó là những gì mà người dùng mong muốn.
    The next message defined in our protocol is the one where we cancel an event. Canceling an event never fails on the client side, so the code is simpler there. 
    Just check whether the event is in the process' state record. If it is, use the <code>event:cancel/1</code> 
    function we defined to kill it and send ok. If it's not found, just tell the user everything went right anyway -- 
    the event is not running and that's what the user wanted.</p>


<pre class="brush:erl">
{Pid, MsgRef, {cancel, Name}} -&gt;
    Events = case orddict:find(Name, S#state.events) of
                 {ok, E} -&gt;
                     event:cancel(E#event.pid),
                     orddict:erase(Name, S#state.events);
                  error -&gt;
                     S#state.events
             end,
    Pid ! {MsgRef, ok},
    loop(S#state{events=Events});
</pre>

<p>Tôt, thật tốt. vậy là giờ tât cả tương tác tùy từ client tới event server đã được thực hiện. Bây giờ việc còn lại của chúng ta là  
    xử  lí những gì xảy ra giữa server và các sự kiện. Có hai dạng tin nhắc mà chúng ta cần phải xú lí: đầu tiên dó là lọai tin hủy bỏ các sự kiện ( cái mà chúng ta đã làm )
    và cái thứ hai đó là các sự kiện mà quá hạn thời gian đợi. Tin nhắc đó sẽ có dạng đơn giản như sau <code>{done, Name}</code>: 

    Good, good. So now all voluntary interaction coming from the client to the event server is covered.
     Let's deal with the stuff that's going between the server and the events themselves. There are two messages to handle: canceling the events (which is done),
      and the events timing out. That message is simply <code>{done, Name}</code>:</p>

<pre class="brush:erl">
{done, Name} -&gt;
    case orddict:find(Name, S#state.events) of
        {ok, E} -&gt;
            send_to_clients({done, E#event.name, E#event.description},
                            S#state.clients),
            NewEvents = orddict:erase(Name, S#state.events),
            loop(S#state{events=NewEvents});
        error -&gt;
            %% This may happen if we cancel an event and
            %% it fires at the same time
            loop(S)
    end;
</pre>

<p>Và hàm <code>send_to_clients/2</code> với chức năng đúng với tên gọi của nó được định nghĩa như sau:
    And the function <code>send_to_clients/2</code> does as its name says and is defined as follows:</p>

<pre class="brush:erl">
send_to_clients(Msg, ClientDict) -&gt;
    orddict:map(fun(_Ref, Pid) -&gt; Pid ! Msg end, ClientDict).
</pre>

<p>Trong hầu hết các đoạn lặp mã nó lên được thực hiện như vậy. Và những gì còn lại bây giờ là các trạng thái khác nhau của tin nhắn như: dạng tin nhắn để  nhận diện client sẽ ngừng hoạt động, 
    khi server ngừng hoạt động ( shutdown ) và nâng cấp mã nguôn, etc. Dưới đây là cách thực hiện chúng:  
    That should be it for most of the loop code. What's left is the set different status messages: clients going down, shutdown, code upgrades, etc. Here they come:</p>

<pre class="brush:erl">
shutdown -&gt;
    exit(shutdown);
{'DOWN', Ref, process, _Pid, _Reason} -&gt;
    loop(S#state{clients=orddict:erase(Ref, S#state.clients)});
code_change -&gt;
    ?MODULE:loop(S);
Unknown -&gt;
    io:format("Unknown message: ~p~n",[Unknown]),
    loop(S)
</pre>

<p>Với trường hợp đầu tiên ở trên ( <code>shutdown</code>), mẫu này nhìn chung chức năng của nó khá rõ ràng. Bạn sẽ nhận được một tin nhắn 
    thông báo về việc chấm dứt tiến trình. Nếu ban muốn lưu trữ trạng thái trong ổ  đĩa, thì đây là mà bạn có thể  thực hiện việc đó.
    Nêu bạn muốn một ngữ nghĩa an toàn hơn để  lưu và thoát, thì bạn có thể  thực hiện nó bằng cách xủ lí tin nhắn trong <code>add</code>, <code>cancel</code> hoặc <code>done</code>
    việc nạp dữ liệu, các sự kiện từ ổ  đĩa vào có thể  thực hiện trong hàm <code>init</code>.
    tức The first case (<code>shutdown</code>) is pretty explicit. You get the kill message, let the process die. 
    If you wanted to save state to disk, that could be a possible place to do it. If you wanted safer save/exit semantics,
     this could be done on every <code>add</code>, <code>cancel</code> or <code>done</code> message. Loading events from disk could then be done in the <code>init</code> function, 
     spawning them as they come.</p>

<p>Với mẫu thông báo <code>'DOWN'</code> thì các hành động thực hiện cũng khá đơn giản. 
    Một khi nhận thông báo này cũng tức là nó báo cho ta biết rằng client cũng đã ngừng hoạt động, vì thế  chỉ cần thực hiẹn chức năng xóa thông tin 
    của client đó trong danh sach trạng thái client là được.
    cùng message's actions are also simple enough. It means a client died, so we remove it from the client list in the state.</p>

<p>Với trường hợp còn lại, trường hợp thông báo mà chúng ta chưa biết dược, rất khó để  xác định để  xủ lí do vậy chỉ cần 
    hiển thị thông tin ra trước cùng với hàm code>io:format/2</code> để  kiểm tra thông tin cho việc gỡ lỗi trước tiên.
    Mặc dù vậy trong một ứng dụng thưc tế  chúng ta thường ít làm theo cách này mà thay thế  nó băng một module logging.

    Unknown messages will just be shown with <code>io:format/2</code> for debugging purposes, although a real production application would likely use a dedicated logging module</p>

<p>Và tiếp theo chúng ta sẽ xét thông báo thay đổi, nâng cấp mã. 
    Đối với tôi nó rất thú vị và đủ để  tôi tạo ra một mục riêng để  viết về  nó: 
    And here comes the code change message. This one is interesting enough for me to give it its own section.</p>


<h3><a class="section" name="hot-code-loving">Hot Code Loving</a></h3>

<p>Để thực hiện nạp mã tức thi ( hot code loading ), Erlang cung cấp một tính năng được gọi là <em>code server</em>.
    về  bản chất <em>code server</em> là một tiến trình máy ảo phục trách quản lí, được lưu trong <a class="docs" href="http://erldocs.com/18.0/stdlib/ets.html">ETS table</a>
    đây là một cấu trúc cở dữ liệu dạng bảng lưu trữ trên RAM, là một phần của máy ảo ). Nó sẽ lưu trữ hai phiên bản mã của một module trong bộ nhớ RAM của máy tính, và chúng 
    đều động thời chạy. Khi một phiên bạn mới của module được tự động nạp và biện dịch cùng với hàm <code>c(Module)</code> hay được nạp bằng hàm <code>l(Module)</code> 
    hay bằng cách nạp cùng với một trong nhiều hàm khác của <a class="docs" href="http://erldocs.com/18.0/kernel/code.html">code module</a>
    In order to do hot code loading, Erlang has a thing called the <em>code server</em>. The code server is basically a VM process 
    in charge of an <a class="docs" href="http://erldocs.com/18.0/stdlib/ets.html">ETS table</a> (in-memory database table, native to the VM.) 
    The code server can hold two versions of a single module in memory, and both versions can run at once. 
    A new version of a module is automatically loaded when compiling it with <code>c(Module)</code>, loading with <code>l(Module)</code> 
    or loading it with one of the many functions of the <a class="docs" href="http://erldocs.com/18.0/kernel/code.html">code module</a>.</p>

<p>Để  hiểu hơn khái niệm này , chúng ta câng hiểu về  khái niệm giữa các cuộc gọi <em>local</em> và <em>external</em> trong Erlang.
    với lời gọi local, đó là những lời gọi hàm chỉ xảy ra bên trong một module và không được export ra sử  dụng bên ngoài các module các. 
    Định dang của những cuộc gọi này có dạng là <code>Atom(Args)</code>. Còn lời gọi external hay nói một cách khác thì đây là lời gọi chỉ thực hiên khi sử  dụng những hàm được 
    export từ một module, chúng sẽ có dạng  <code>Module:Function(Args)</code>. 
    A concept to understand is that Erlang has both <em>local</em> and <em>external</em> calls. Local calls are those function calls you can make with functions that might not be exported. 
    They're just of the format <code>Atom(Args)</code>. An external call, on the other hand, can only be done with exported functions and has the form <code>Module:Function(Args)</code>.</p>

<p>Quay trở lại, khi hai phiển bản của module đươc nạp vào cùng một Máy ảo, 
    lúc đó tât cả các lời gọi hàm local sẽ được thực hiên bởi phiên bản đạng chạy của tiến trình, tuy nhiên với những lời gọi hàm external, chúng se <strong>luôn luôn</strong> sử  dụng cùng với 
    phiên bản mới nhất của mã có sẵn trên code server. sau đó khi một lời gọi hàm local mà được thực hiện bên trong một lời gọi hàm external, thì nó sẽ sử  dụng phiên bản mới của mã
    
    When there are two versions of a module loaded in the VM, all local calls are done through the currently running version in a process. However, external calls are <strong>always</strong> 
    done on the newest version of the code available in the code server. Then, if local calls are made from within the external one, they are in the new version of the code.</p>

<img class="center explanation" src="static/img/hot-code-loading.png" width="513" height="307" alt="A fake module showing local calls staying in the old 
version and external calls going on the new one" />

<p>Bạn thấy rằng mỗi tiến trình, actor trong Erlang cần một lời gọi đề  quy để  thay đổi trạng thái, tuy nhiên 
    bạn vẫn có thê sử  dụng các lời gọi đệ quy từ các module khác để  nạp toàn bộ các phiên bản cập nhật mới của actỏ
    Given that every process/actor in Erlang needs to do a recursive call in order to change its state, 
    it is possible to load entirely new versions of an actor by having an external recursive call.</p>

<div class="note">
<p><strong>Lưu ý:</strong> nếu bạn tải một phiên bản thứ 3 của một module trong khi tiến trình, ứng dụng của bạn vẫn đang chạy cùng với bản module đầu tiên,
    thì Máy ảo sẽ nhìn nhận và chấm dứt nó. Bởi vì nó sẽ coi tiến trình này như một tiến trình độc lập mà không có sự giám sát của bất kỳ tiến trình giám sát nào hoặc không có 
    khả năng nâng cấp. Trong trường hợp nếu không có bất kỳ một tiến trình nào đang sử  dụng phiên bản cũ nhất, thì nó sẽ tự động được loại bỏ và thay thế  bằng phiên bản mới nhất. 
    If you load a third version of a module while a process still runs with the first one, that process gets killed by the VM, 
    which assumes it was an orphan process without a supervisor or a way to upgrade itself. If nobody runs the oldest version, it is simply dropped and the newest ones are kept instead.</p>
</div>

<p>Trong Erlang cũng hỗ  trợ một số  công cụ để  thông báo cho bạn biết khi có bất cứ một phiên bản cật nhập mới nào được tải , nạp vào trong ứng dụng.
    Việc này sẽ giúp bạn có thể  chủ động hơn trong việc tải lại module khi nhận được thông báo. Khi nhận được thông báo này,
    hãy luôn lưu ý tới việc sử  dụng hàm nâng cấp mã <code>MyModule:Upgrade(CurrentState)</code>, hàm này sẽ giúp bạn chuyển trạng thái của cấu trúc dữ liệu
    trong bản hiện tai sang bản mới nhất. 'subscription' cũng sẽ được xử  lý tự động bởi OTP framework, đây là một framework quan trọng trong Erlang và 
    chúng ta sẽ đi tim hiểu chúng ở các chương sau. Đói với ứng dụng trong chương này để  hiểu rõ hơn chúng ta sẽ không sử  dụng code server cho việc nâng cấp 
    mà thay vào đó chúng ta sẽ đi viết một chức năng gửi thông báo <code>code_change</code> riêng từ shell. Dưới đây là ví dụ tổng quát:
    There are ways to bind yourself to a system module that will send messages whenever a new version of a module is loaded. 
    By doing this, you can trigger a module reload only when receiving such a message, and always do it with a code upgrade function, 
    say <code>MyModule:Upgrade(CurrentState)</code>, which will then be able to transform the state data structure according to the new version's specification. 
    This 'subscription' handling is done automatically by the OTP framework, which we'll start studying soon enough. For the reminder application, 
    we won't use the code server and will instead use a custom <code>code_change</code> message from the shell, doing very basic reloading.
     That's pretty much all you need to know to do hot code loading. Nevertheless, here's a more generic example:</p>

<pre class="brush:erl">
-module(hotload).
-export([server/1, upgrade/1]).

server(State) -&gt;
    receive
        update -&gt;
            NewState = ?MODULE:upgrade(State),
            ?MODULE:server(NewState);  %% loop in the new version of the module
        SomeMessage -&gt;
            %% do something here
            server(State)  %% stay in the same version no matter what.
    end.

upgrade(OldState) -&gt;
    %% transform and return the state here.
</pre>

<p>như bạn thấy, hàm <code>?MODULE:loop(S)</code> hoàn toàn tương thích với mẫu này.
    As you can see, our <code>?MODULE:loop(S)</code> fits this pattern.</p>


<h3><a class="section" name="hide-your-messages">I Said, Hide Your Messages</a></h3>

<p>Ẩn Các tin nhắn! Nếu bạn muốn người khác dựa vào đoạn và các tiến trình mà bạn viết, bạn sẽ phải ẩn đi các tin nhắn giao giao diện hàm.
    Dưới đầy là những chúng ta sử  dụng cho module <code>server</code>
    Hiding messages! If you expect people to build on your code and processes, you must hide the messages in interface functions. Here's what we used for the <code>evserv</code> module:</p>

<pre class="brush:erl">
start() -&gt;
    register(?MODULE, Pid=spawn(?MODULE, init, [])),
    Pid.

start_link() -&gt;
    register(?MODULE, Pid=spawn_link(?MODULE, init, [])),
    Pid.

terminate() -&gt;
    ?MODULE ! shutdown.
</pre>

<p>Tôi đã quyết định đăng ký module server bởi vì lúc này tôi chỉ lên có một phiên bản tiến trình của nó chạy nó mà thôi. Nếu bạn muốn mở rộng ứng dụng ra với việc hỗ trợ nhiều người dùng, 
    thì một ý kiến hay là bạn lên đăng ký các tên đó cùng với <a class="docs" href="http://erldocs.com/18.0/stdlib/global.html">global module</a> hoặc sư dụng <a class="docs" href="http://github.com/uwiger/gproc">gproc library</a>
    . Đối với nhu câu của ưng dụng trong ví dụ này thì một là đủ.

    I decided to register the server module because, for now, we should only have one running at a time. If you were to expand the reminder use to support many users, 
    it would be a good idea to instead register the names with the <a class="docs" href="http://erldocs.com/18.0/stdlib/global.html">global module</a>, 
    or the <a class="docs" href="http://github.com/uwiger/gproc">gproc library</a>. For the sake of this example app, this will be enough.</p>

<p>Bây giờ chúng ta sẽ đi xét tin nhắn đầu tiên, nó được định nghĩa để  mổ  tả cách đăng ký.
    Dựa trên giao thức hay đặc điểm kỹ thuật mà chúng ta đã nói phía trên với việc sử  dụng một màn hình hình giám sát ( monitor ), chúng ta sẽ áp dụng
    nó ở đây. Tại bất cứ thời điểm nào nếu một tiến trình tham chiếu được trả về  bởi một tin nhắn đăng ký với nội dung là <code>DOWN</code>, thì client 
    sẽ biết được rằng khi đó server đã ngừng hoạt động.
    The first message we wrote is the next we should abstract away: how to subscribe. The little protocol or specification I wrote above called for a monitor, so this one is added there.
     At any point, if the reference returned by the subscribe message is in a <code>DOWN</code> message, the client will know the server has gone down.</p>

<pre class="brush:erl">
subscribe(Pid) -&gt;
    Ref = erlang:monitor(process, whereis(?MODULE)),
    ?MODULE ! {self(), Ref, {subscribe, Pid}},
    receive
        {Ref, ok} -&gt;
            {ok, Ref};
        {'DOWN', Ref, process, _Pid, Reason} -&gt;
            {error, Reason}
    after 5000 -&gt;
        {error, timeout}
    end.
</pre>

<p>với một sự kiện khi được thêm mới vào 
    The next one is the event adding:</p>

<pre class="brush:erl">
add_event(Name, Description, TimeOut) -&gt;
    Ref = make_ref(),
    ?MODULE ! {self(), Ref, {add, Name, Description, TimeOut}},
    receive
        {Ref, Msg} -&gt; Msg
    after 5000 -&gt;
        {error, timeout}
    end.
</pre>

<p>Lưu ý là tôi lựa chọn việc chuyển tiếp tới thông báo <code>{error, bad_timeout}</code>  tới client. Tôi cũng có thể 
    thể  quyết định gây ra crash cho client bầng cách đưa ra một ngoại lệ <code>erlang:error(bad_timeout)</code>.
    Việc chọn giữa hai cách này vẫn còn đang được công dồng tiếp tục tranh luận, vì thế   Dưới đầy là một hàm thay thế  crash.

    Note that I choose to forward the <code>{error, bad_timeout}</code> message that could be received to the client. 
    I could have also decided to crash the client by raising <code>erlang:error(bad_timeout)</code>. 
    Whether crashing the client or forwarding the error message is the thing to do is still debated in the community. Here's the alternative crashing function:</p>

<pre class="brush:erl">
add_event2(Name, Description, TimeOut) -&gt;
    Ref = make_ref(),
    ?MODULE ! {self(), Ref, {add, Name, Description, TimeOut}},
    receive
        {Ref, {error, Reason}} -&gt; erlang:error(Reason);
        {Ref, Msg} -&gt; Msg
    after 5000 -&gt;
        {error, timeout}
    end.
</pre>

<p>Tiếp đó, khi một sự kiện bị hủy bỏ, chúng ta chỉ cần dựa trên tên sự kiện là đủ:
    Then there's event cancellation, which just takes a name:</p>

<pre class="brush:erl">
cancel(Name) -&gt;
    Ref = make_ref(),
    ?MODULE ! {self(), Ref, {cancel, Name}},
    receive
        {Ref, ok} -&gt; ok
    after 5000 -&gt;
        {error, timeout}
    end.
</pre>

<p>Cuối cùng là một tính năng nhỏ được cung cấp cho khách hàng, một hàm dùng để  tổng hợp tất cả các tin nhắc dựa trên thời gian nhất định.
    Nếu các tin nhắn được tìm thấy, chúng sẽ được lấy ra đọc và sớm trả về  một hàm khi có thể : 
    Last of all is a small nicety provided for the client, a function used to accumulate all messages during a given period of time. If messages are found, 
    they're all taken and the function returns as soon as possible:</p>

<pre class="brush:erl">
listen(Delay) -&gt;
    receive
        M = {done, _Name, _Description} -&gt;
            [M | listen(0)]
    after Delay*1000 -&gt;
        []
    end.
</pre>


<h3><a class="section" name="a-test-drive">A Test Drive</a></h3>

<p>Bây giờ bạn có thể  biện dịch ứng dụng ra chay thử  được rồi. Để  làm cho mọi thứ trở lên đơn giản hơn, chúng ta sẽ tạo ra một makefile để  tự động giúp cho việc 
    xây dựng dữ án. Hãy tạo ra một file đặt tên là <code>Emakefile</code> và để  nó ở trong thư mục gốc của dự án này. Bên trong file này 
    chúng ta sẽ sử  dụng một số  thuật ngữ của Erlang để  đưa ra một công thức cho trình biên dịch của Erlang để  tạo ra các file <code>.beam</code>:
    You should now be able to compile the application and give it a test run. To make things a bit simpler, 
    we'll write a specific Erlang makefile to build the project. Open a file named <code>Emakefile</code> and put it in the project's base directory. 
    The file contains Erlang terms and gives the Erlang compiler the recipe to cook wonderful and crispy <code>.beam</code> files:</p>

<img class="right" src="static/img/oven.png" width="230" height="229" alt="An old oven with smoke coming out of it" />

<pre class="expand">
{'src/*', [debug_info,
           {i, "src"},
           {i, "include"},
           {outdir, "ebin"}]}.
</pre>

<p>Đoạn mã trên sẽ cho trình biên dịch biết debug_info lên được thêm vào trong các file ( đây là một lựa chọn mà bạn hiếm khi có thể  từ chối ), 
    nó cũng sẽ tièm kiếm các file trong thư mục <code>src/</code> và <code>include/</code> và xuất chúng tới thư mục <code>ebin/</code>.
    This tells the compiler to add debug_info to the files (this is rarely an option you want to give up), to look for files in the <code>src/</code> and <code>include/</code> 
    directory and to output them in <code>ebin/</code>.</p>

<p>Nào bậy giờ hay mở terminal lên mà gõ dòng lệnh sau <code>erl -make</code>, bạn sẽ thấy tất cả các file sẽ được biên dịch và đặt trong thư mục <code>ebin/</code>.
    Tiếp đó hay chạy lệnh <code>erl -pa ebin/</code> để  bắt đầu shell. tham số  <code>-pa &lt;directory&gt;</code> sẽ cho Máy ảo Erlang biết đường dẫn chưa các file module 
    được thêm vào ngoài đường dẫn nơi chưa các thư viên chuẩn của Erlang. 

    Now, by going in your command line and running <code>erl -make</code>, the files should all be compiled and put inside the <code>ebin/</code> directory for you. 
    Start the Erlang shell by doing <code>erl -pa ebin/</code>. The <code>-pa &lt;directory&gt;</code> option tells the Erlang VM to add that path to the places it can look in for modules.</p>

<p>Một cách khác đó là trong shell bạn gọi tới lệnh <code>make:all([load])</code>. Khi gọi lệnh này file 'Emakefile' sẽ được nó tìm kiếm tại thư mục nơi bạn bắt đầu 
    shell và biên dịch lại nó ( nếu như có bất kỳ sự thay đổi nào trong dự án) và tải các file mới vào máy ảo. 
    Another option is to start the shell as usual and call <code>make:all([load])</code>. This will look for a file named 'Emakefile' in the current directory, 
    recompile it (if it changed) and load the new files.</p>

<p>Bậy giờ bạn có thể  theo dõi hàng ngàn các sự kiện rồi ( Chỉ cần thay thế  biến <var>DateTime</var>  bằng bất cứ giá trị hợp lệ nào khác mà bạn muốn)
    You should now be able to track thousands of events (just replace the <var>DateTime</var> variables with whatever makes sense when you're writing the text):</p>
<pre class="brush:eshell">
1&gt; evserv:start().
&lt;0.34.0&gt;
2&gt; evserv:subscribe(self()).
{ok,#Ref&lt;0.0.0.31&gt;}
3&gt; evserv:add_event("Hey there", "test", FutureDateTime).
ok
4&gt; evserv:listen(5).
[]
5&gt; evserv:cancel("Hey there").
ok
6&gt; evserv:add_event("Hey there2", "test", NextMinuteDateTime).
ok
7&gt; evserv:listen(2000).
[{done,"Hey there2","test"}]
</pre>

<p>Thật tuyệt. Bây giờ chỉ cần sử  dụng các hàm giao tiếp chúng ta đã tạo lên là bạn có thể  đơn giản viết đươc bất kỳ client nào rồi.
    Nice nice nice. Writing any client should now be simple enough given the few basic interface functions we have created.</p>


<h3><a class="section" name="adding-supervision">Adding Supervision</a></h3>

<p>Để  làm cho ứng dụng ổn định hơn, chúng ta lên viết thêm một chức năng  'restarter' như chúng ta đã làm trước đó trong chương <a class="chapter" href="errors-and-processes.html#naming-processes"> last chapter</a>
    Hãy tao ra một file module mới và đặt tên nó là <a class="source" href="static/erlang/sup.erl.html">sup.erl</a>, đâu sẽ là file mà chúng ta thực hiện chức năng giám sát:
    In order to be a more stable application, we should write another 'restarter' as we did in the <a class="chapter" href="errors-and-processes.html#naming-processes"> last chapter</a>. 
    Open up a file named <a class="source" href="static/erlang/sup.erl.html">sup.erl</a> where our supervisor will be:</p>

<pre class="brush:erl">
-module(sup).
-export([start/2, start_link/2, init/1, loop/1]).

start(Mod,Args) -&gt;
    spawn(?MODULE, init, [{Mod, Args}]).

start_link(Mod,Args) -&gt;
    spawn_link(?MODULE, init, [{Mod, Args}]).

init({Mod,Args}) -&gt;
    process_flag(trap_exit, true),
    loop({Mod,start_link,Args}).

loop({M,F,A}) -&gt;
    Pid = apply(M,F,A),
    receive
        {'EXIT', _From, shutdown} -&gt;
            exit(shutdown); % will kill the child too
        {'EXIT', Pid, Reason} -&gt;
            io:format("Process ~p exited for reason ~p~n",[Pid,Reason]),
            loop({M,F,A})
    end.
</pre>

<p>Nó sẽ tượng tự như cách mà 'restarter' đã làm, mặc dù ở đây nó được viết tổng quá hơn và có thể  chấp nhận bất kỳ một module nào ,  
    miễn sao hàm <code>start_link</code> đã được dịnh nghĩa sẵn. Nó sẽ có chức động lại tiến trình mà nó theo dõi vô thời hạn trừ khi 
    supervisor ngừng hoạt động bằng cách tạo một exit sign. Dứoi đây là cách sử  dụng nó:
    This is somewhat similar to the 'restarter', although this one is a tad more generic. It can take any module, 
    as long as it has a <code>start_link</code> function. It will restart the process it watches indefinitely, 
    unless the supervisor itself is terminated with a shutdown exit signal. Here it is in use:</p>

<pre class="brush:eshell">
1&gt; c(evserv), c(sup).
{ok,sup}
2&gt; SupPid = sup:start(evserv, []).
&lt;0.43.0&gt;
3&gt; whereis(evserv).
&lt;0.44.0&gt;
4&gt; exit(whereis(evserv), die).
true
Process &lt;0.44.0&gt; exited for reason die
5&gt; exit(whereis(evserv), die).
Process &lt;0.48.0&gt; exited for reason die
true
6&gt; exit(SupPid, shutdown).
true
7&gt; whereis(evserv).
undefined
</pre>

<p>Như bạn thấy, chấm dứt supervisor cũng sẽ chấm dứt tất cả các tiến trình con của nó.
    As you can see, killing the supervisor will also kill its child.</p>

<div class="note">
    <p><strong>Lưu ý:</strong> Các tính năng cao cấp hơn và linh hoạt hơn của supervisors, chúng ta sẽ được học trong chương về  OTP supervisors.
        Khi nhắc tới <em>supervision trees</em>, OTP supervisors là những gì mà nhiều người thường nghĩ ngay tới.
        trong vi dụ này chức ta chỉ thực hiện chức nẵng cơ bản nhất của supervisor mà thôi. Trong môi trường thực tế  chúng ta sé sử  dụng supervisors
        ở một chức năng cao hơn.
        We'll see much more advanced and flexible supervisors in the chapter about OTP supervisors. 
        Those are the ones people are thinking of when they mention <em>supervision trees</em>. 
        The supervisor demonstrated here is only the most basic form that exists and is not exactly fit for production environments compared to the real thing.</p>
</div>

<h3><a class="section" name="namespaces">Namespaces (or lack thereof)</a></h3>

<img class="left" src="static/img/gentleman.png" width="334" height="298" alt="A Gentleman about to step in a pile of crap" title="Mentlegent!" />

<p>Một phần bởi vì Erlang sử  dụng một cấu trục module phẳng ( không có sự phân cấp giữa các module) do đó các ứng dụng sẽ không tránh khỏi xung đọt giữa các module với nhau 
    Một ví dụ tiêu biểu đó là module <code>user</code> thường xuyên được định nghĩa trong hầu hết các dự án ít nhất một lần,
    và module này có thể  sẽ xung đột với module <code>user</code> định nghĩa trong Erlang. Để  kiểm tra bạn có thể  
    xem và kiểm tra cùng với hàm <code><a class="docs" href="http://erldocs.com/18.0/kernel/code.html#clash/0">code:clash/0</a></code>.
    
    Because Erlang has a flat module structure (there is no hierarchy), 
    It is frequent for some applications to enter in conflict. 
    One example of this is the frequently used <code>user</code> module that almost every project attempts to define at least once. 
    This clashes with the <code>user</code> module shipped with Erlang. You can test for any clashes with the function 
    <code><a class="docs" href="http://erldocs.com/18.0/kernel/code.html#clash/0">code:clash/0</a></code>.</p>

<p>Do đó để  giải quyết vấn đề  này chúng ta thường lên thêm tiền tố  tên dự án của bạn vào trước các tên phổ  biến thường để  
    đặt cho module. rong ví dụ này, các module ứng dụng của chúng ta đổi tên lại thành <code>reminder_evserv</code>, <code>reminder_sup</code> and <code>reminder_event</code>.
    Because of this, the common pattern is to prefix every module name with the name of your project. In this case, 
    our reminder application's modules should be renamed to <code>reminder_evserv</code>, <code>reminder_sup</code> and <code>reminder_event</code>.</p>

<p>Some programmers then decide to add a module, named after the application itself, which wraps common calls that programmers 
    could use when using their own application. Example calls could be functions such as starting the application with a supervisor, 
    subscribing to the server, adding and cancelling events, etc.</p>

<p>Quan trọng là nhận thức được namespaces để  tránh đăng ký các tên trùng với các tên đã tồn tại hay các tên bảng trong cơ sở dữ liệu.  
    It's important to be aware of other namespaces, too, such as registered names that must not clash, database tables, etc.</p>

<p>That's pretty much it for a very basic concurrent Erlang application. This one showed we could have a bunch of concurrent 
    processes without thinking too hard about it: supervisors, clients, servers, processes used as timers (and we could have thousands of them), 
    etc. No need to synchronize them, no locks, no real main loop. Message passing has made it simple to compartmentalize our application into a 
    few modules with separated concerns and tasks.</p>

<p>The basic calls inside <a class="source" href="static/erlang/evserv.erl.html">evserv.erl</a> could now be used to construct clients 
    that would allow to interact with the event server from somewhere outside of the Erlang VM and make the program truly useful.</p>

<p>Before doing that, though, I suggest you read up on the OTP framework. The next few chapters will cover some of its building blocks, 
    which will allow for much more robust and elegant applications. A huge part of Erlang's power comes from using it. 
    It's a carefully crafted and well-engineered tool that any self-respecting Erlang programmer has to know.</p>
				<ul class="navigation">
											<li><a href="errors-and-processes.html" title="Previous chapter">&lt; Previous</a></li>
										
					<li><a href="contents.html" title="Index">Index</a></li>
					
											<li><a href="what-is-otp.html" title="Next chapter">Next &gt;</a></li>
									</ul>
			</div><!-- content -->
			<div id="footer">
				<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details"><img src="static/img/cc.png" width="88" height="31" alt="Creative Commons Attribution Non-Commercial No Derivative License" /></a>
				<p>Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution Non-Commercial No Derivative License</p>
			</div> <!-- footer -->
		</div> <!-- wrapper -->
		<div id="grass" />
	<script type="text/javascript" src="static/js/shCore.js"></script>
	<script type="text/javascript" src="static/js/shBrushErlang2.js%3F11"></script>
	<script type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.all();
	</script>
	</body>
</html>
