<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="keywords" content="Erlang, exception, error, exit, throw, try, catch, crash, runtime, process" />
		<meta name="description" content="A list of compile-time errors and warnings, runtime errors in Erlang. Also errors, exits and throws then how to handle them with try ... catch and other constructs." />
        <meta name="google-site-verification" content="mi1UCmFD_2pMLt2jsYHzi_0b6Go9xja8TGllOSoQPVU" />
		<link rel="stylesheet" type="text/css" href="static/css/screen.css%3Fv3.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shCore.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/sh/shThemeLYSE2.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="static/css/print.css" media="print" />
		<link href="rss" type="application/rss+xml" rel="alternate" title="LYSE news" />
		<link rel="icon" type="image/png" href="favicon.ico" />
		<link rel="apple-touch-icon" href="static/img/touch-icon-iphone.png" />
		<link rel="apple-touch-icon" sizes="72x72" href="static/img/touch-icon-ipad.png" />
		<link rel="apple-touch-icon" sizes="114x114" href="static/img/touch-icon-iphone4.png" />
		<title>Errors and Exceptions | Learn You Some Erlang for Great Good!</title>
	</head>
	<body>
		<div id="wrapper">
			<div id="header">
				<h1>Learn you some Erlang</h1>
				<span>for great good!</span>
			</div> <!-- header -->
			<div id="menu">
				<ul>
					<li><a href="content.html" title="Home">Home</a></li>
					<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
					<li><a href="rss" title="Latest News">RSS</a></li>
					<li><a href="static/erlang/learn-you-some-erlang.zip" title="Source Code">Code</a></li>
				</ul>
			</div><!-- menu -->
			<div id="content">
            <div class="noscript"><noscript>Hey there, it appears your Javascript is disabled. That's fine, the site works without it. However, you might prefer reading it with syntax highlighting, which requires Javascript!</noscript></div>
<h2>Errors and Exceptions</h2>
<h3><a class="section" name="not-so-fast">Not so fast!</a></h3>

<img class="left" src="static/img/cyclist.png" width="268" height="252" alt="A green man with a huge head and tiny body on a bicycle" title="I don't know why I drew that" />

<p>Trong cuốn sách này bạn sẽ không thể  tìm thấy một chương nào giống chương này,
   xuyên suốt các chương trước đó bạn đã học cách viết một module, chương trình và chạy chung, bạn cũng học cách giải quyết vấn để  với các lỗi xảy ra,
   tuy nhiên điều đó là chưa đủ để  kiểm soát và xử  lí chúng. hơn nữa, thực tế  có rất nhiều các lỗi, do đó chúng ra không thể bao quát hết được tất cả các lỗi 
   ( kể cả trong chương này chúng ra cũng ko thể  đề  cập tất cả các cơ chế  xử  lí lỗi được).
   Một điều nữa là trong Erlang có chút khác biệt về  lỗi, nó gồm hai mô hinh chính sau: <code>functional</code> và <code>concurrent</code>.Trong 
   đó functional là một tập các thánh phần là mà chúng ta đa tìm hiểu xuyên suốt các chương trước đó của cuốn sách: referential transparency, recursion, higher order functions, etc
   . concurrent là một tập cá thành phần tạo lên ưu thế  cho Erlang: actors, thousands and thousands of concurrent processes, supervision trees, etc.</p

<p>Do đó trong chương này tỗi sẽ chỉ đề  cập tới các lỗi nằm trong 'functional' , còn các lỗi trong 'concurrent' chúng ta sẽ tìm hiểu chúng ngay sau khi 
    tìm hiểu các thành phần của 'concurrent'. Đối với lỗi , để có thể  kiểm soát được chúng, trước tiên ta phải hiểu rõ chúng trước đã.</p>

<div class="note">
    <p><strong>Lưu ý:</strong> mặc dù Erlang cho phép sử  dụng một số  phương pháp để  kiểm soát lỗi trong functional code, nhưng như tôi đã đề  cập 
        trước đó ở chương đâu của cuốn sách <a class="chapter" href="introduction.html#what-is-erlang">Introduction</a>. Bạn sẽ không xử  lí lỗi theo cách thông thường 
        mà phần lớn thời gian sẽ áp dụng một cơ chế  xử  lí lỗi khác, hay gọi là 'Let it crash'. Trong phân 'concurrent' của cuốn sách chúng ta se đi tìm hiểu về  nó.</p>
</div>


<h3><a class="section" name="a-compilation-of-errors">A Compilation of Errors</a></h3>

<p>Trong Erlang lỗi dược chia thành nhiều loại: các lỗi khi biên dịch ( compile-time errors ), các lỗi logic ( logical errors ), lỗi xảy ra trong quá trình chạy ( run-time errors) 
    và lỗi phát sinh (generated errors). Trong phần này tôi sẽ tập vào các lỗi biên dịch. đối với các lỗi còn lại chúng ta sẽ tìm hiểu ở các phần sau.</p>

<p>Lỗi biên dịch là lỗi thường xảy ra do người lập trình sai xót về  mặt cú pháp: vd như 
    việc kiểm tra, khai báo tên của một hàm, các ký tự token (dấu ngoặc vuông, dấu ngoặc vuông, dấu chấm, dấu phẩy) , đối số  của một hàm (arity function), etc.
    Sau đây là danh sách các lỗi về  biện dịch thường thấy và cách giải quyết chúng khi bạn gặp phải:</p>

<dl>
	<dt>module.beam: Module name 'madule' does not match file name 'module'</dt>
	<dd>Lỗi này cho ta biết tên của của module mà bạn định nghĩa trong <code>-module</code> trong một file thì không khớp với tên của file.</dd>

	<dt>./module.erl:2: Warning: function some_function/0 is unused</dt>
	<dd>Lỗi này cho ta biết bạn không export hàm cần sử  dụng ở bên ngoài module gốc hay sử  dụng sau tên hàm hoặc sai đối số  tại nơi bạn đang sử  dụng hàm đó. 
        Hoặc cũng có thể  cảnh báo rằng hàm bạn viết ra thì không được sử  dụng ở bất cứ đâu. vì vậy hãy kiểm tra kỹ lại code của bạn!</dd>

	<dt>./module.erl:2: function some_function/1 undefined</dt>
    <dd>Lỗi này cho ta biết hàm này không tồn tại, có thể  bạn viết sai tên hàm hay sai đối số  chỉ định trong <code>-export</code>.
        Lỗi này cũng xảy ra trong trường hợp hàm bạn định nghĩa không thể biên dịch được do sai cú pháp như quên dấu <var>.</var> để kết thúc hàm.</dd>

	<dt>./module.erl:5: syntax error before: 'SomeCharacterOrWord'</dt>
	<dd>Lỗi này xảy ra trong một số  trương hợp như quên đóng dấu ngoặc trong danh sách, bộ , 
        quên ký tự để  kết thúc hay chuyển tiếp một câu lệnh ,biểu thức ( vd như quên kết thúc một biểu thức <code>case</code> với từ <code>end</code> hay chuyển tiếp lệnh với dấu <code>,</code>). 
        hay một số trường hợp đặc biệt như sử  reserved atom (stop, ok, etc ) hay chuyển đổi giữa các ký tự unicode đặc biệt với nhau</dd> 

	<dt>./module.erl:5: syntax error before: </dt>
	<dd>Đây là trường hợp đặc biệt của lỗi trên, mô tả của nó không thực sự rõ ràng, nó thường xảy ra khi một dòng lệnh không được kết thúc chính xác do đó hay cẩn thận kiểm tra kỹ càng.</dd>

	<dt>./module.erl:5: Warning: this expression will fail with a 'badarith' exception</dt>
	<dd>Mặc dù mọi thứ trong Erlang là 'dynamic typing', nhưng đừng quên là types trong Erlang rất strong. 
        Và bộ biên dịch của Erlang rất thông minh trong việc tìm ra sai xót trong các biểu thức số học (vd như lỗi <code>llama + 5</code>). 
        Tuy vậy đối với các lỗi phức tạp hơn thì không thể .</dd>

	<dt>./module.erl:5: Warning: variable 'Var' is unused</dt>
    <dd>Lỗi này xảy ra khi bạn khai báo một biến nhưng lại không sử  dụng nó. 
        lỗi này thương liên quan tới sai xót trong đoạn mã của bạn vid vậy hãy kiểm tra kỹ lại những gì bạn viết vả sử dụng. 
        Trong trường hợp , bạn cố  ý sử  dụng thì hãy thêm trước tên biến đó dấu gạch dưới <var>_Var</var> hoặc chuyển sang xài biến <code>_</code>,
        Nó sẽ giúp bạn đọc mã tốt hơn và ko xảy ra lỗi này.</dd>

	<dt>./module.erl:5: Warning: a term is constructed, but never used</dt>
	<dd>Lỗi này xảy ra trong một hàm khi bạn đang tính làm một thứ gì đó như xây dựng một danh sách, khai báo một bộ, anonymous function 
        mà quên không liên kết nó với một giá trị như là giá trị trả về. Cảnh báo cho bạn biết bạn có sai xót ở đâu đấy hoặc sử  dụng thứ gì đó một cách lãng phí.</dd>

    <dt>./module.erl:5: head mismatch</dt>
    <dd>Lỗi này xảy ra khi hàm của bạn có nhiều hơn một tham số  đầu vào và mỗi chúng lại có một arity khác nhau. Hãy nhớ rằng 
        cùng tên hàm nhưng khác đối số  là các hàm khác nhau, trong Erlang không có overload, do đó bạn không được phép khai báo theo cách đó.
        nó cũng có thể  xảy ra khi bạn chèn một hàm định nghĩa mới giữa hai khoản của một hàm đang đinh nghĩa ( hàm này chưa kết thúc).</dd>

    <dt>./module.erl:5: Warning: this clause cannot match because a previous clause at line 4 always matches</dt>
    <dd>Lỗi này xảy ra khi một hàm khai báo trong một module có một mệnh đề được đinh nghĩa sau một catch-all, 
        trình biên dịch sẽ nhìn nhận và coi nó như một lỗi để cảnh báo bạn
        A function defined in the module has a specific clause defined after a catch-all one. As such, the compiler can warn you that you'll never even need to go to the other branch.</dd>

   <dt>./module.erl:9: variable 'A' unsafe in 'case' (line 5)</dt>
   <dd>Lỗi này xảy ra khi bạn đang sử dụng một biến, mà biến đó được đinh nghĩa thông qua một nhánh khớp của <code>case ... of</code> ở bên ngoài. 
    Nó là một hành vi không an toàn. Trong trường hợp bạn muốn sử  dụng theo biên trong biểu thức đó , bạn lên tạo ra một biến và gán nó vơi biểu thức ,
    bên trong biểu thưc trả về  kết quả vd như <code>MyVar = case ... of</code>...</dd>
</dl>

<p>Trên là các lỗi biên dịch phổ  biến hay gặp. Không có quá nhiều lỗi biện dịch cho lắm tuy nhiên thông thường chúng sẽ xảy ra theo một chuỗi các lỗi liệt kê phía trên lên việc tìm kiếm cũng khó khăn.
    There aren't too many and most of the time the hardest part is finding which error caused a huge cascade of errors listed against other functions. 
Do đó cách tốt hơn là giải quyết các lỗi biên dịch này theo thứ tự mà chúng đưa ra để  tránh việc sữa những lỗi mà không thực sự xảy ra.  It is better to resolve compiler errors in the order they were reported to avoid being misled by errors which may not actually be errors at all. 
Trong trương hợp nếu bạn gặp phải các lỗi biên dịch khác mà không có trong danh sách liệt kê phía trên, hãy gửi email cho tôi, tôi sẽ cật nhât chúng vào danh sách cùng với giải thích nó sớm.</p>


<h3><a class="section" name="no-u">No, YOUR logic is wrong!</a></h3>

<img class="right" src="static/img/exam.png" width="232" height="224" alt="An exam with the grade 'F'" title="This is the worst essay on underwater breakdancing I have ever read!" />

<p>Tiếp theo chúng ra sẽ nói tới một trong những lỗi khó nhất để  tìm và gỡ lỗi , lỗi logic. chúng là những lỗi gây ra bởi các lập trinh viên trong quá trình code để  giải quyết một vấn đề  nào đó
    : vd như bỏ xót một số  trường hợp kiểm tra điều kiện trong một số  nhánh của biểu thức kiểm tra 'if' và  'case', 
    They're most likely errors coming from the programmer: branches of conditional statements such as 'if's and 'case's that don't consider all the cases, sử  dụng phép nhân thay vì phép chia gây nhâm 
    lẫn kết quả, etc. Những lỗi này thông thường không làm crash chương trình nhưng thay vào đó nó sẽ hiển thị cho bạn những kết quả xấu không mong muốn.</p>

<p>Với những lỗi logic như vậy bạn có thể  tự giải quyết chúng nhưng sẽ mất thời gian hơn do đo Erlang cũng cấp cho bạn rất nhiều
    công cụ thuânt tiện để  giải quyết, bao gồm: các framework kiểm thử, TypEr và Dialyzer (bạn có thể  xem lại chương <a class="chapter" href="types-or-lack-thereof.html#for-type-junkies">types chapter</a>), 
    công cụ gỡ lỗi ( 
        <a class="docs" href="http://www.erlang.org/doc/apps/debugger/debugger_chapter.html" title="official documentation">debugger</a> ) và 
        <a class="docs" href="http://erldocs.com/18.0/runtime_tools/dbg.html" title="link to non-official documentation">tracing module</a>, etc. 
        Cách tốt nhất để  bảo, tránh khỏi những lỗi như vậy là kiểm thử  đoạn mã của bạn. Có một điều không may là trong bất kỳ sự nghiệp của mỗi lập trình viên thì gặp những lỗi như vậy đủ để  viết vài
        chục cuốn sách do đó tôi sẽ không danh nhiêu thời gian và đi chi tiết vào chúng nữa, thay vào đó chúng ta lên tập trung hơn về  những lỗi có thể  gây crash chương trình. Bởi vì những lỗi như vậy , chúng
        dễ  dàng thấy được hơn là những lỗi về mặt logic và sẽ không bubble up tới ̀̀đ cấp độ (won't bubble up 50 levels from now).
        Một lưu ý nữa là với những lỗi gây ảnh hưởng tới chương trình như này có khả năng là tiền đề  cho thuật ngữ  'let it crash' mà tôi đã đề cập trước đó.
        Note that this is pretty much the origin of the 'let it crash' ideal I mentioned a few times already.</p>


<h3><a class="section" name="run-time-errors">Run-time Errors</a></h3>

<p>Các lỗi trong quá trình chạy ( Run-time errors ) là một trong những lỗi rất nguy hiểm và khiến cho đọan mã của bạn bị crash.
   .Nhưng đùng lo lắng, Erlang có rất nhiều cách để  giải quyết các lỗi như vậy và nó rât có lợi cho bạn sau này, nếu nhận thức các lỗi như vậy. 
   Để  hiểu rõ hơn tôi sẽ đưa ra một vài ví dụ thường gặp về  các lỗi xảy ra trong quá trình chạy.</p>

<dl>
    <dt>function_clause</dt>
    <dd>
        <pre class="brush:eshell">
1&gt; lists:sort([3,2,1]). 
[1,2,3]
2&gt; lists:sort(fffffff). 
** exception error: no function clause matching lists:sort(fffffff)
        </pre>
    </dd>
    <dd>Với một hàm, một số  lỗi xảy ra khi không có mệnh để  của hàm nào khớp với mẫu đã đưa ra hoặc tât cả các mệnh đề  đều không thỏa mãn.</dd>

    <dt>case_clause</dt>
    <dd>
        <pre class="brush:eshell">
3&gt; case "Unexpected Value" of 
3&gt;    expected_value -&gt; ok;
3&gt;    other_expected_value -&gt; 'also ok'
3&gt; end.
** exception error: no case clause matching "Unexpected Value"
        </pre>
    </dd>
    <dd>Lỗi này thường xảy ra khi một ai đó quên xác định điều kiện cụ thể  trong biểu thức <code>case</code>, hay dùng sai kiểu dư liệu 
        hoặc không bắt tất cả các trường hợp có thể  xảy ra trong biểu thức <code>case</code>!</dd>

    <dt>if_clause</dt>
    <dd>
        <pre class="brush:eshell">
4&gt; if 2 &gt; 4 -&gt; ok;
4&gt;    0 &gt; 1 -&gt; ok
4&gt; end.
** exception error: no true branch found when evaluating an if expression
        </pre>
    </dd>
    <dd>Lỗi này khá giống với các lỗi ở <code>case_clause</code>: 
        không có bất kỳ điều kiện nào đúng ( được khớp với <code>true</code>). 
        Vì vậy để chắc chắc không xảy ra, hãy bắt tất cả các trường hợp có thể xảy ra hay luôn chèn thêm điều kiện  
        <code>true</code> như một điều kiện mặc định nếu tât cả các điệu kiện mà bạn đưa vào đều không đúng.</dd>

    <dt>badmatch</dt>
    <dd>
        <pre class="brush:eshell">
5&gt; [X,Y] = {4,5}.
** exception error: no match of right hand side value {4,5}
        </pre>
    </dd>
    <dd>lỗi này xảy ra khi bạn nhần lẫn trong việc so sánh khớp mẫu của 2 
        vế  khác nhau. vd như trên khi bạn đang cố  só khớp hai mẫu nhưng chúng hoàn toàn khác nhau,
        hoặc trong trường hợp khi một biến đã được liên kết giá trị ròi nhưng bạn vẫn tiếp tục liên kết với giá trị khác,
        hoặc giá trị của cả hai vế  không khớp với nhau. Một lưu ý nữa là đôi khi người lập trình nhầm tưởng biến <var>_MyVar</var> và 
        <code>_</code> là tương đương nhau do đó họ dùng chúng tương đương cho cả hai vế  của so sánh hoặc liên kết chúng với một giá trị khác 
        do đó cũng có thẻ gây lên lỗi này. Hay nhớ rằng việc sử  dụng ký tự gạch dưới cho một biến không có nghĩa là có thể sử dụng biến đó nhiều lần 
        để  liên kết vói giá trị khác đươc, thực tế trình biên dịch sẽ ghi nhận việc sử  tên biến có ký tự gạch dưới ở phía trước vẫn là một biến bình thường nhưng 
        thay vào đó nó sẽ phớt lờ biến đó đi nếu nó không được sử  dụng thôi.</dd>

    <dt>badarg</dt>
    <dd>
        <pre class="brush:eshell">
6&gt; erlang:binary_to_list("heh, already a list").
** exception error: bad argument
     in function  binary_to_list/1
        called as binary_to_list("heh, already a list")
        </pre>
    </dd>
    <dd>Lỗi này tương tự như lỗi trong <code>function_clause</code>, nó sẽ xảy khi không có mẫu ( điều kiện ) nào khớp với mẫu ở hàm đinh sẵn nhưng 
        ở lỗi này nó sẽ đưa ra thông báo chi tiết hơn, việc bạn sử  dụng không chính xác đối số  trong một hàm định sẵn,
        điều khác biệt ở đây là lỗi này thường gây ra bởi lập trình viên sử  dụng sai đối số  truyền vào khi gọi hàm chứ không phải là 
        các biểu thức chốt canh hay khớp mâũ củ hàm. Một lát nữa tôi sẽ cho bạn thấy cách để  tạo ra lỗi này như này.</dd>

    <dt>undef</dt>
    <dd>
        <pre class="brush:eshell">
7&gt; lists:random([1,2,3]).
** exception error: undefined function lists:random/1
        </pre>
    </dd>
    <dd>Lỗi này xỷ ra khi hàm bạn muốn gọi không được định nghĩa. Hãy đảm bảo rằng hàm đó đã được export tử  module mà nó được định nghĩa và chính xác đối số 
        (nếu bạn muốn sử  dụng nó ở các module khác ), và kiểm tra kỹ các lỗi chính tả với tên của hàm và tên của module  
        . Ngoài ra bạn cũng có bắt gặp lỗi cùng với thông điệp này trong trường hợp Erlang không thể  tìm thấy được đường dẫn chưa module này  
        . Mặc định , Erlang sẽ tìm kiếm đường dẫn ở thưc mục hiện tại. 
        tuy nhiên bạn có thể  thêm các đường dẫn khác bằng việc sử  dụng <code><a class="docs" href="http://erldocs.com/18.0/kernel/code.html#add_patha/1" 
            title="I'll kill my brain finding new titles for the unofficial doc site">code:add_patha/1</a></code> hay 
            <code><a class="docs" href="http://erldocs.com/18.0/kernel/code.html#add_pathz/1" title="It's becoming hard to have new ideas">code:add_pathz/1</a></code>. 
            Trong trường hợp nó không hoạt động, hãy kiểm tra xem module đó đã được biên dịch hay chưa!</dd>

    <dt>badarith</dt>
    <dd>
        <pre class="brush:eshell">
8&gt; 5 + llama.
** exception error: bad argument in an arithmetic expression
     in operator  +/2
        called as 5 + llama
        </pre>
    </dd>
    <dd>Lỗi này xảy ra khi bạn đang cố  thực hiện một phép số  học trái quy tắc , vd như 
        chia một số  cho 0 hay thực hiện phép tihs giữa kiểu dữ liệu số  và kiểu dữ liệu atom.</dd>

    <dt>badfun</dt>
    <dd>
        <pre class="brush:eshell">
9&gt; hhfuns:add(one,two).
** exception error: bad function one
in function  hhfuns:add/2
        </pre>
    </dd>
    <dd>Lỗi này xảy ra khi bạn cố  sử  dụng một biến như một hàm, nhưng giá trị của biến đó không phải là hàm.
        nhu trong ví dụ tôi sử  dụng hàm <code>hhfuns</code> từ chương <a class="chapter local" href="higher-order-functions.html">higher-order-functions</a> 
        và sử  dụng hai atom như các hàm, do đó lỗi  <code>badfun</code> được ném ra.</dd>

    <dt>badarity</dt>
    <dd>
        <pre class="brush:eshell">
10&gt; F = fun(_) -&gt; ok end.
#Fun&lt;erl_eval.6.13229925&gt;
11&gt; F(a,b).
** exception error: interpreted function with arity 1 called with two arguments
        </pre>
    </dd>
    <dd>lỗi <code>badarity</code> là một trường hợp đặc biệt riêng của lỗi <code>badfun</code>: 
        nó xảy ra khi bạn sử  dụng higher order functions, nhưng đối số  mà vào ít hơn hay nhiều hơn giá đối số  được phép.</dd>

    <dt>system_limit</dt>
    <dd>lỗi <code>system_limit</code> xảy ra do rất nhiều nguyên nhân: có quá nhiều tiến trình ( chúng ta xem tim hiểu sau )
        , sử  dụng các atom cùng tên quá dài, sử  dụng quá nhiều đối số  trong một hàm, số  lượng atom sử  dụng quá nhiều , quá nhiều nút kết nối với nhau, etc.
        để tìm hiểu chi tiết về các lỗi này, bạn có thể  xem tại <a class="docs" href="http://www.erlang.org/doc/efficiency_guide/advanced.html#id2265856">Erlang Efficiency Guide</a> mục 
        <code>system limits</code>. Một điều lưu ý nữa là một số  lỗi có thể  gây crash toàn bộ máy ảo.</dd>
</dl>

<h3><a class="section" name="raising-exceptions">Raising Exceptions</a></h3>

<img class="right" src="static/img/stop.png" width="148" height="179" alt="A stop sign" title="... Hammer time!" />

<p>để  giám sát việc thực hiện của các đoạn mã và bảo vệ khỏi các lỗi logic, một ý kiến được đưa để  phát hiện các vẫn đề, lỗi sớm là việc tạo ra, gây ra một số  lỗi crash trong quá trình chạy.</p>

<p>có tất cả ba loại ngoại lệ trong Erlang: đó là <em>errors</em>, <em>throws</em> và <em>exits</em>. Mỗi chúng sẽ có cách sử  dụng khác nhau và ta sẽ đi vào chi tiết từng ngoại lệ cụ thê:</p>

<h4>Errors</h4>
<p>Đây là ngoại lệ chúng ta sẽ tìm hiểu đầu tiên, băng cách gọi hàm <code>erlang:error(Reason)</code> , tại thời điểm gọi, nó sẽ chấm dứt tiến trình hiện tại , tiếp đó nó sẽ cung cấp cho bạn 
    dấu vết của ngăn xếp cùng với hàm gần nhất mà được gọi cùng với đối số  của hàm đó.
    will end the execution in the current process and include a stack trace of 
    the last functions called with their arguments when you catch it. 
    Đây là một trong những ngoại lệ gây ra trong quá trình chạy mà tôi đã cập ở trên..</p>

<p>Errors are the means for a function to stop its execution when you can't expect the calling code to handle what just happened.
   Giả sử  như bạn nhạn được môt lỗi <code>if_clause</code>, Bạn sẽ làm gì với nó ? Sửa đoạn mã đó và biên dịch lại, 
   Đó là tất cả những gì bạn có thể  làm được ( tốt hơn việc chỉ hiện thị một thông báo lỗi ).
   Hay một vd về  viêc sử dụng trường hơp mặc định đẻ tránh không tạo ra lỗi như trong module <code>tree</code> mà chúng ta đã làm trong  
   <a class="chapter local" href="recursion.html#more-than-lists" title="More than lists">more-than-lists</a>. 
   Việc thực hiện tìm kiếm node, từ khóa xác định trong một cây không phải lúc nào cũng tìm được,
   để  tránh việc không tìm được gây ra lỗi, chúng ta sẽ tạo ra một trường hợp mặc đinh đôi với các kết quả mà không 
   biết được: như việc sử  dụng một giá trị mặc định, kiểm tra điều kiện để  chèn một giá trị mới vào, xóa bỏ cây, etc.
   Tốt hơn là kết quả trả về  một cấu trúc bộ có dạng <code>{ok, Value}</code> đối với một kết quả có giá trị và một atom <code>undefined</code>
   với các trương hợp không có giá trị hoặc không tìm được thay vì trả về  lỗi.</p>
   what can you do? Change the code and recompile, that's what you can do .
   other than just displaying a pretty error message). An example of when not to use errors could be our tree module from the 
   <a class="chapter local" href="recursion.html#more-than-lists" title="More than lists">more-than-lists</a>. 
   That module might not always be able to find a specific key in a tree when doing a lookup. 
   In this case, it makes sense to expect the user to deal with unknown results: they could use a default value, 
   check to insert a new one, delete the tree, etc. This is when it's appropriate to return a tuple of the form <code>{ok, Value}</code> 
   or an atom like <code>undefined</code> rather than raising errors.</p>

<p>Tuy vậy các lỗi thì không bị giới hạn phạm vi như các ví dụ trên, Bạn cũng có thể  định nghĩa các lỗi của chính bạn như vd sau:</p>

<pre class="brush:eshell">
1&gt; erlang:error(badarith).
** exception error: bad argument in an arithmetic expression
2&gt; erlang:error(custom_error).
** exception error: custom_error
</pre>

<p>Nhìn xem, bạn thấy lỗi <code>custom_error</code> thì không được ghi nhận bởi Erlang đông thời cũng không có thông điệp kèm theo như "bad argument in ...", 
    Nhưng nó được sử  dụng theo cùng một cách và xử  lí tương tự như các lỗi khác ( ở phần sau, chúng ta sẽ thấy làm điều đó như nào).</p>

<h4>Exits</h4>
<p>Trong Erlang, có hai loại exits cần phải phân biệt rõ: 'internal' exits và 'external' exits. 
    Internal exits được gọi ra bằng cách gọi hàm  <code>exit/1</code>, sau khi gọi nó sẽ ngững ngay tiến trình hiện tại. 
    External exits được gọi ra bằng cách gọi hàm <code>exit/2</code> và được sử  dụng khi bạn làm việc cùng đa tiến trình trong concurrent aspect of Erlang; 
    Trong chương này chúng ta sẽ tập trung phần lớn vào internal exits và nói sơ qua external exits sau đó.</p>

<p>Internal exits gần giống với lỗi (errors). 
    thực tế  trong các bài phát biểu, chúng thường được tạo ra bởi cùng một cách gọi <code>exit/1</code> và sư dụng trong cùng trường hợp.
    Thật sự mơ hồ, vậy làm thế  nào để  xác đinh giữa chúng ? Để  hiểu, phân biệt được khi nào sử  dụng cái nào,
    chúng ta phải đi xét khai niệm của tiến trình ( process ) và actor.</p>

    They've got roughly the same use cases. So how to choose one? Well the choice is not obvious. To understand when to use one or the other, 
    there's no choice but to start looking at the concepts of actors and processes from far away.</p>

<p>Như trong chương đầu, Tôi nói về  tiến trình và đã ví von các tiến trình với những người giao tiếp qua lại qua mail , do đó tương tự chúng ta
    sẽ không đề  cập nhiều hơn nữa mà sẽ minh họa chúng thông qua các biểu đồ  bong bóng sau. 
. There's not a lot to add to the analogy, so I'll go to diagrams and bubbles.</p>

<img src="static/img/a-b-msg.png" width="221" height="83" alt="A process 'A' represented by a circle, sending a message (represented by an arrow) to a process 'B' (another circle)" title="whoa!" />

<p>Như trong hình bạn sẽ thấy các tiến trình ( process ) sẽ gửi các thông điệp ( message ) cho nhau. 
    một tiến trình cũng có thể  lắng nghe , đợi một thông điệp mới tới. 
    đồng thời bạn cũng có thể  lưa chọn lắng nghe hay loại bỏ, bỏ qua hay chấm dứt việc lắng nghe sau một khoảng thời gian nhất định, etc.</p>

<img src="static/img/a-b-c-hello.png" width="226" height="143" alt="A process 'A' sending 'hello' to a process 'B', which in turns messages C with 'A says hello!'" title="B is the third wheel here" />

<p> Từ các khai niệm cơ bản trên cho phép nhưng người phát triển của Erlang có thể  sử  dụng các loại thông điệp 
    đặc biệt cho việc giao tiếp ngoại lệ giữa các tiến trình với nhau, hay có thể  coi chúng như 'last breath' của một tiến trình.
    Chũng sẽ được gửi tới trước khi tiến trình tạch và chưa các doạn mạng đê dừng việc thực thi.
    Hay một số các trình khác trình đang lắng nghe , đợi một số  loại thông điệp cụ thể  có thể biết được các sự kiện và thực hiện một điều gì đó bởi các 
    thông điệp đặc biệt này. thông thường nó gồm có logging và phụ hồi trạng thái của tiến trình mà đã tách trước đó, etc.</p>

    These basic concepts let the implementors of Erlang use a special kind of message to communicate exceptions between processes. 
    They act a bit like a process' last breath; they're sent right before a process dies and the code it contains stops executing. 
    Other processes that were listening for that specific kind of message can then know about the event and do whatever they please with it. 
    This includes logging, restarting the process that died, etc.</p>

<img src="static/img/a-b-dead.png" width="266" height="86" alt="A dead process (a bursting bubble) sending 'I'm dead' to a process 'B'" title="" />

<p>Bằng cách giải thích trên, ta có thấy thấy rõ sự khác nhau khi sử  dụng giữa <code>erlang:error/1</code> và <code>exit/1</code>.
   Mặc dù cả hai được sử  dụng theo cách giống nhau , nhưng sự khác biệt thực sự đến từ mục đích mà muốn sử  dụng chúng.
   Khi nhận môi lỗi như vậy bạn có thể  quyét định giũa việc coi nó là một lỗi 'đơn giản' hay là một điều kiện để  chấm dứt tiến trình hiện tại đi.
   Một sự lưu ý là hàm <code>erlang:error/1</code>  sẽ trả vê một dấu vết ngăn xếp , ngược lại hàm <code>exit/1</code> thì không.
   While both can be used in an extremely similar manner, the real difference is in the intent. 
   You can then decide whether what you've got is 'simply' an error or a condition worthy of killing the current process. 
   This point is made stronger by the fact that <code>erlang:error/1</code> returns a stack trace and <code>exit/1</code> doesn't. 
   If you were to have a pretty large stack trace or lots of arguments to the current function, 
   copying the exit message to every listening process would mean copying the data. In some cases, this could become unpractical.</p>

<h4>Throws</h4>
<p>một throw là một lớp của ngoại lệ và được sử  dụng để  tạo ra các ngoại lệ mong muốn is a class of exceptions used for cases that the programmer can be expected to handle. In comparison with exits and errors, they don't really carry any 'crash that process!' intent behind them, but rather control flow. As you use throws while expecting the programmer to handle them, it's usually a good idea to document their use within a module using them.</p>

<p>The syntax to throw an exception is:</p>

<pre class="brush:eshell">
1&gt; throw(permission_denied).
** exception throw: permission_denied
</pre>

<p>Where you can replace <code>permission_denied</code> by anything you want (including <code>'everything is fine'</code>, but that is not helpful and you will lose friends).</p>

<p>Throws can also be used for non-local returns when in deep recursion. An example of that is the <code><a class="docs" href="http://erldocs.com/18.0/ssl/ssl.html" title="you don't actually need to click this to understand the chapter">ssl</a></code> module which uses <code>throw/1</code> as a way to push <code>{error, Reason}</code> tuples back to a top-level function. This function then simply returns that tuple to the user. This lets the implementer only write for the successful cases and have one function deal with the exceptions on top of it all.</p>

<p>Another example could be the array module, where there is a lookup function that can return a user-supplied default value if it can't find the element needed. When the element can't be found, the value <code>default</code> is thrown as an exception, and the top-level function handles that and substitutes it with the user-supplied default value. This keeps the programmer of the module from needing to pass the default value as a parameter of every function of the lookup algorithm, again focusing only on the successful cases.</p>

<img class="right" src="static/img/catch.png" width="107" height="248" alt="A fish that was caught" title="catch the pun" />

<p>As a rule of thumb, try to limit the use of your throws for non-local returns to a single module in order to make it easier to debug your code. It will also let you change the innards of your module without requiring changes in its interface.</p>


<h3><a class="section" name="dealing-with-exceptions">Dealing with Exceptions</a></h3>

<p>I've already mentioned quite a few times that throws, errors and exits can be handled. The way to do this is by using a <code>try ... catch</code> expression.</p>

<p>A <code>try ... catch</code> is a way to evaluate an expression while letting you handle the successful case as well as the errors encountered. The general syntax for such an expression is:</p>

<pre class="brush:erl">
try Expression of
    SuccessfulPattern1 [Guards] -&gt;
        Expression1;
    SuccessfulPattern2 [Guards] -&gt;
        Expression2
catch
    TypeOfError:ExceptionPattern1 -&gt;
        Expression3;
    TypeOfError:ExceptionPattern2 -&gt;
        Expression4
end.
</pre>

<p>The <var>Expression</var> in between <code>try</code> and <code>of</code> is said to be <em>protected</em>. This means that any kind of exception happening within that call will be caught. The patterns and expressions in between the <code>try ... of</code> and <code>catch</code> behave in exactly the same manner as a <code>case ... of</code>. Finally, the <code>catch</code> part: here, you can replace <var>TypeOfError</var> by either <code>error</code>, <code>throw</code> or <code>exit</code>, for each respective type we've seen in this chapter. If no type is provided, a <code>throw</code> is assumed. So let's put this in practice.</p>

<p>First of all, let's start a module named <code><a class="source" href="static/erlang/exceptions.erl.html">exceptions</a></code>. We're going for simple here:</p>

<pre class="brush:erl">
-module(exceptions).
-compile(export_all).

throws(F) -&gt;
    try F() of
        _ -&gt; ok
    catch
        Throw -&gt; {throw, caught, Throw}
    end.
</pre>

<p>We can compile it and try it with different kinds of exceptions:</p>

<pre class="brush:eshell">
1&gt; c(exceptions).
{ok,exceptions}
2&gt; exceptions:throws(fun() -&gt; throw(thrown) end).
{throw,caught,thrown}
3&gt; exceptions:throws(fun() -&gt; erlang:error(pang) end).
** exception error: pang
</pre>

<p>As you can see, this <code>try ... catch</code> is only receiving throws. As stated earlier, this is because when no type is mentioned, a throw is assumed. Then we have functions with catch clauses of each type:</p>

<pre class="brush:erl">
errors(F) -&gt;
    try F() of
        _ -&gt; ok
    catch
        error:Error -&gt; {error, caught, Error}
    end.

exits(F) -&gt;
    try F() of
        _ -&gt; ok
    catch
        exit:Exit -&gt; {exit, caught, Exit}
    end.
</pre>

<p>And to try them:</p>

<pre class="brush:eshell">
4&gt; c(exceptions).
{ok,exceptions}
5&gt; exceptions:errors(fun() -&gt; erlang:error("Die!") end).
{error,caught,"Die!"}
6&gt; exceptions:exits(fun() -&gt; exit(goodbye) end).
{exit,caught,goodbye}
</pre>

<p>The next example on the menu shows how to combine all the types of exceptions in a single <code>try ... catch</code>. We'll first declare a function to generate all the exceptions we need:</p>

<pre class="brush:erl">
sword(1) -&gt; throw(slice);
sword(2) -&gt; erlang:error(cut_arm);
sword(3) -&gt; exit(cut_leg);
sword(4) -&gt; throw(punch);
sword(5) -&gt; exit(cross_bridge).

black_knight(Attack) when is_function(Attack, 0) -&gt;
    try Attack() of
        _ -&gt; "None shall pass."
    catch
        throw:slice -&gt; "It is but a scratch.";
        error:cut_arm -&gt; "I've had worse.";
        exit:cut_leg -&gt; "Come on you pansy!";
        _:_ -&gt; "Just a flesh wound."
    end.
</pre>

<p>Here <code>is_function/2</code> is a BIF which makes sure the variable <var>Attack</var> is a function of arity 0. Then we add this one for good measure:</p>

<pre class="brush:erl">
talk() -&gt; "blah blah".
</pre>

<p><cite>And now for something completely different</cite>:</p>

<pre class="brush:eshell">
7&gt; c(exceptions).
{ok,exceptions}
8&gt; exceptions:talk().
"blah blah"
9&gt; exceptions:black_knight(fun exceptions:talk/0).
"None shall pass."
10&gt; exceptions:black_knight(fun() -&gt; exceptions:sword(1) end).
"It is but a scratch."
11&gt; exceptions:black_knight(fun() -&gt; exceptions:sword(2) end).
"I've had worse."
12&gt; exceptions:black_knight(fun() -&gt; exceptions:sword(3) end).
"Come on you pansy!"
13&gt; exceptions:black_knight(fun() -&gt; exceptions:sword(4) end).
"Just a flesh wound."
14&gt; exceptions:black_knight(fun() -&gt; exceptions:sword(5) end).
"Just a flesh wound."
</pre>

<img class="right" src="static/img/black-knight.png" width="221" height="262" alt="Monty Python's black knight" title="Just a flesh wound." />

<p>The expression on line 9 demonstrates normal behavior for the black knight, when function execution happens normally. Each line that follows that one demonstrates pattern matching on exceptions according to their class (throw, error, exit) and the reason associated with them (<code>slice</code>, <code>cut_arm</code>, <code>cut_leg</code>).</p>

<p>One thing shown here on expressions 13 and 14 is a catch-all clause for exceptions. The <code>_:_</code> pattern is what you need to use to make sure to catch any exception of any type. In practice, you should be careful when using the catch-all patterns: try to protect your code from what you can handle, but not any more than that. Erlang has other facilities in place to take care of the rest.</p>

<p>There's also an additional clause that can be added after a <code>try ... catch</code> that will always be executed. This is equivalent to the 'finally' block in many other languages:</p>

<pre class="brush:erl">
try Expr of
    Pattern -&gt; Expr1
catch
    Type:Exception -&gt; Expr2
after % this always gets executed
    Expr3
end
</pre>

<p>No matter if there are errors or not, the expressions inside the <code>after</code> part are guaranteed to run. However, you can not get any return value out of the <code>after</code> construct. Therefore, <code>after</code> is mostly used to run code with side effects. The canonical use of this is when you want to make sure a file you were reading gets closed whether exceptions are raised or not.</p>

<p>We now know how to handle the 3 classes of exceptions in Erlang with catch blocks. However, I've hidden information from you: it's actually possible to have more than one expression between the <code>try</code> and the <code>of</code>!</p>

<pre class="brush:erl">
whoa() -&gt;
    try
        talk(),
        _Knight = "None shall Pass!",
        _Doubles = [N*2 || N &lt;- lists:seq(1,100)],
        throw(up),
        _WillReturnThis = tequila
    of
        tequila -&gt; "hey this worked!"
    catch
        Exception:Reason -&gt; {caught, Exception, Reason}
    end.
</pre>

<p>By calling <code>exceptions:whoa()</code>, we'll get the obvious <code>{caught, throw, up}</code>, because of <code>throw(up)</code>. So yeah, it's possible to have more than one expression between <code>try</code> and <code>of</code>...</p>

<p>What I just highlighted in <code>exceptions:whoa/0</code> and that you might have not noticed is that when we use many expressions in that manner, we might not always care about what the return value is. The <code>of</code> part thus becomes a bit useless. Well good news, you can just give it up:</p>

<pre class="brush:erl">
im_impressed() -&gt;
    try
        talk(),
        _Knight = "None shall Pass!",
        _Doubles = [N*2 || N &lt;- lists:seq(1,100)],
        throw(up),
        _WillReturnThis = tequila
    catch
        Exception:Reason -&gt; {caught, Exception, Reason}
    end.
</pre>

<p>And now it's a bit leaner!</p>

<div class="note">
    <p><strong>Note:</strong> It is important to know that the protected part of an exception can't be tail recursive. The VM must always keep a reference there in case there's an exception popping up.</p>

	<p>Because the <code>try ... catch</code> construct without the <code>of</code> part has nothing but a protected part, calling a recursive function from there might be dangerous for programs supposed to run for a long time (which is Erlang's niche). After enough iterations, you'll go out of memory or your program will get slower without really knowing why. By putting your recursive calls between the <code>of</code> and <code>catch</code>, you are not in a protected part and you will benefit from Last Call Optimisation.</p>

	<p>Some people use <code>try ... of ... catch</code> rather than <code>try ... catch</code> by default to avoid unexpected errors of that kind, except for obviously non-recursive code with results that won't be used by anything. You're most likely able to make your own decision on what to do!</p>
</div>


<h3><a class="section" name="theres-more">Wait, there's more!</a></h3>

<p>As if it wasn't enough to be on par with most languages already, Erlang's got yet another error handling structure. That structure is defined as the keyword <code>catch</code> and basically captures all types of exceptions on top of the good results. It's a bit of a weird one because it displays a different representation of exceptions:</p>

<pre class="brush:eshell">
1&gt; catch throw(whoa).
whoa
2&gt; catch exit(die).
{'EXIT',die}
3&gt; catch 1/0.
{'EXIT',{badarith,[{erlang,'/',[1,0]},
                   {erl_eval,do_apply,5},
                   {erl_eval,expr,5},
                   {shell,exprs,6},
                   {shell,eval_exprs,6},
                   {shell,eval_loop,3}]}}
4&gt; catch 2+2.
4
</pre>

<p>What we can see from this is that throws remain the same, but that exits and errors are both represented as <code>{'EXIT', Reason}</code>. That's due to errors being bolted to the language after exits (they kept a similar representation for backwards compatibility).</p>

<p>The way to read this stack trace is as follows:</p>

<pre class="brush:eshell">
5&gt; catch doesnt:exist(a,4).              
{'EXIT',{undef,[{doesnt,exist,[a,4]},
                {erl_eval,do_apply,5},
                {erl_eval,expr,5},
                {shell,exprs,6},
                {shell,eval_exprs,6},
                {shell,eval_loop,3}]}}
</pre>
<ul>
    <li>The type of error is <code>undef</code>, which means the function you called is not defined (see the list at the beginning of this chapter)</li>
    <li>The list right after the type of error is a stack trace</li>
    <li>The tuple on top of the stack trace represents the last function to be called (<code>{Module, Function, Arguments}</code>). That's your undefined function.</li>
    <li>The tuples after that are the functions called before the error. This time they're of the form <code>{Module, Function, Arity}</code>.</li>
    <li>That's all there is to it, really.</li>
</ul>

<p>You can also manually get a stack trace by calling <code>erlang:get_stacktrace/0</code> in the process that crashed.</p>

<p>You'll often see <code>catch</code> written in the following manner (we're still in <a class="source" href="static/erlang/exceptions.erl.html">exceptions.erl</a>):</p>

<pre class="brush:erl">
catcher(X,Y) -&gt;
    case catch X/Y of
        {'EXIT', {badarith,_}} -&gt; "uh oh";
        N -&gt; N
    end.
</pre>

<p>And as expected:</p>

<pre class="brush:eshell">
6&gt; c(exceptions).
{ok,exceptions}
7&gt; exceptions:catcher(3,3).
1.0
8&gt; exceptions:catcher(6,3).
2.0
9&gt; exceptions:catcher(6,0).
"uh oh"
</pre>

<p>This sounds compact and easy to catch exceptions, but there are a few problems with <code>catch</code>. The first of it is operator precedence:</p>

<pre class="brush:eshell">
10&gt; X = catch 4+2.
* 1: syntax error before: 'catch'
10&gt; X = (catch 4+2).
6
</pre>

<p>That's not exactly intuitive given that most expressions do not need to be wrapped in parentheses this way. Another problem with <code>catch</code> is that you can't see the difference between what looks like the underlying representation of an exception and a real exception:</p>

<pre class="brush:eshell">
11&gt; catch erlang:boat().
{'EXIT',{undef,[{erlang,boat,[]},
                {erl_eval,do_apply,5},
                {erl_eval,expr,5},
                {shell,exprs,6},
                {shell,eval_exprs,6},
                {shell,eval_loop,3}]}}
12&gt; catch exit({undef, [{erlang,boat,[]}, {erl_eval,do_apply,5}, {erl_eval,expr,5}, {shell,exprs,6}, {shell,eval_exprs,6}, {shell,eval_loop,3}]}). 
{'EXIT',{undef,[{erlang,boat,[]},
                {erl_eval,do_apply,5},
                {erl_eval,expr,5},
                {shell,exprs,6},
                {shell,eval_exprs,6},
                {shell,eval_loop,3}]}}
</pre>

<p>And you can't know the difference between an error and an actual exit. You could also have used <code>throw/1</code> to generate the above exception. In fact, a <code>throw/1</code> in a <code>catch</code> might also be problematic in another scenario:</p>

<pre class="brush:erl">
one_or_two(1) -&gt; return;
one_or_two(2) -&gt; throw(return).
</pre>

<p>And now the killer problem:</p>

<pre class="brush:eshell">
13&gt; c(exceptions).
{ok,exceptions}
14&gt; catch exceptions:one_or_two(1).
return
15&gt; catch exceptions:one_or_two(2).
return
</pre>

<p>Because we're behind a <code>catch</code>, we can never know if the function threw an exception or if it returned an actual value! This might not really happen a whole lot in practice, but it's still a wart big enough to have warranted the addition of the <code>try ... catch</code> construct in the R10B release.</p>


<h3><a class="section" name="try-a-try-in-a-tree">Try a try in a tree</a></h3>

<p>To put exceptions in practice, we'll do a little exercise requiring us to dig for our <code><a class="source" href="static/erlang/tree.erl.html">tree</a></code> module. We're going to add a function that lets us do a lookup in the tree to find out whether a value is already present in there or not. Because the tree is ordered by its keys and in this case we do not care about the keys, we'll need to traverse the whole thing until we find the value.</p>

<p>The traversal of the tree will be roughly similar to what we did in <code>tree:lookup/2</code>, except this time we will always search down both the left branch and the right branch. To write the function, you'll just need to remember that a tree node is either <code>{node, {Key, Value, NodeLeft, NodeRight}}</code> or <code>{node, 'nil'}</code> when empty. With this in hand, we can write a basic implementation without exceptions:</p>

<pre class="brush:erl">
%% looks for a given value 'Val' in the tree.
has_value(_, {node, 'nil'}) -&gt;
    false;
has_value(Val, {node, {_, Val, _, _}}) -&gt;
    true;
has_value(Val, {node, {_, _, Left, Right}}) -&gt;
    case has_value(Val, Left) of
        true -&gt; true;
        false -&gt; has_value(Val, Right)
    end.
</pre>

<p>The problem with this implementation is that every node of the tree we branch at has to test for the result of the previous branch:</p>

<img class="center explanation" src="static/img/tree-case.png" width="495" height="176" alt="A diagram of the tree with an arrow following every node checked while traversing the tree, and then when returning the result" />

<p>This is a bit annoying. With the help of throws, we can make something that will require less comparisons:</p>

<pre class="brush:erl">
has_value(Val, Tree) -&gt; 
    try has_value1(Val, Tree) of
        false -&gt; false
    catch
        true -&gt; true
    end.

has_value1(_, {node, 'nil'}) -&gt;
    false;
has_value1(Val, {node, {_, Val, _, _}}) -&gt;
    throw(true);
has_value1(Val, {node, {_, _, Left, Right}}) -&gt;
    has_value1(Val, Left),
    has_value1(Val, Right).
</pre>

<p>The execution of the code above is similar to the previous version, except that we never need to check for the return value: we don't care about it at all. In this version, only a throw means the value was found. When this happens, the tree evaluation stops and it falls back to the <code>catch</code> on top. Otherwise, the execution keeps going until the last <samp>false</samp> is returned and that's what the user sees:</p>

<img class="center explanation" src="static/img/tree-throw.png" width="495" height="176" alt="A diagram of the tree with an arrow following every node checked while traversing the tree, and then skipping all the nodes on the way back up (thanks to a throw)" />

<p>Of course, the implementation above is longer than the previous one. However, it is possible to realize gains in speed and in clarity by using non-local returns with a throw, depending on the operations you're doing. The current example is a simple comparison and there's not much to see, but the practice still makes sense with more complex data structures and operations.</p>

<p>That being said, we're probably ready to solve real problems in sequential Erlang.</p>
				<ul class="navigation">
											<li><a href="higher-order-functions.html" title="Previous chapter">&lt; Previous</a></li>
										
					<li><a href="contents.html" title="Index">Index</a></li>
					
											<li><a href="functionally-solving-problems.html" title="Next chapter">Next &gt;</a></li>
									</ul>
			</div><!-- content -->
			<div id="footer">
				<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License Details"><img src="static/img/cc.png" width="88" height="31" alt="Creative Commons Attribution Non-Commercial No Derivative License" /></a>
				<p>Except where otherwise noted, content on this site is licensed under a Creative Commons Attribution Non-Commercial No Derivative License</p>
			</div> <!-- footer -->
		</div> <!-- wrapper -->
		<div id="grass" />
	<script type="text/javascript" src="static/js/shCore.js"></script>
	<script type="text/javascript" src="static/js/shBrushErlang2.js%3F11"></script>
	<script type="text/javascript">
		SyntaxHighlighter.defaults.gutter = false;
		SyntaxHighlighter.all();
	</script>
	</body>
</html>
